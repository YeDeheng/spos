Regexp	^
to	P
match	V
Javascript	^
string	N
literals	V
with	P
a	D
specific	A
keyword	^
using	V
Java	^

After	P
much	A
revision	N
(	,
see	V
edit	V
history	N
,	,
viewers	N
at	P
home	N
:)	E
,	,
I	O
believe	V
this	D
is	V
my	D
final	A
answer	N
:	,

It	O
does	V
when	R
I	O
test	V
it	O
...	,
test	N
case	N
3	E
matches	V
properly	R
as	P
2	$
string	N
literals	V
.	,
Here	R
is	V
where	R
the	D
original	A
regex	N
came	V
from	P
http://blog.stevenlevithan.com/archives/match-quoted-string	U

Oops	!
,	,
I	O
see	V
.	,
Yeah	!
,	,
it's	L
relying	V
on	P
the	D
non-greedy	A
behavior	N
for	P
that	O
,	,
which	D
you	O
can't	V
use	V
the	D
same	A
way	N
because	P
you're	L
anchoring	V
to	P
a	D
keyword	^
.	,
Editing	!
...	~

That	O
should	V
work	N
but	&
the	D
problem	N
in	P
my	D
case	N
would	V
be	V
false-positives	V
.	,
The	D
probability	N
of	P
a	D
string	N
literal	N
having	V
the	D
special	A
keyword	^
is	V
about	P
1%	$
.	,
And	&
I	O
have	V
to	P
process	N
a	D
lot	N
of	P
files	N
with	P
hundreds	N
of	P
lines	V
every	D
time	N
.	,
If	P
no	D
one	N
can	V
come	V
up	T
with	P
a	D
way	N
to	P
pre-screen	V
the	D
literals	^
for	P
the	D
special	A
keyword	^
before	P
processing	V
them	O
,	,
I'll	L
go	V
with	P
your	D
solution	N
.	,

Maybe	R
further	A
developments	N
will	V
help	N
...	,

It	O
seems	V
to	P
match	V
a	D
lot	N
more	R
than	P
needed	V
.	,
In	P
my	D
test	N
case	N
chunk	N
above	P
,	,
it	O
matched	V
:	,
"	,
test	N
"	,
;	G
var	G
v2	$
=	G
"	,
testkeyword	^
"	,
;	E
var	E
v3	E
=	E
"	,
test	N
"	,
;	G
var	^
v4	$
=	G
"	,
testkeyword	^
"	,
;	,

Tim's	Z
modification	N
of	P
your	D
Regexp	^
above	P
works	V
correctly	R
.	,

Cool	A
.	,
Glad	A
to	P
have	V
helped	V
,	,
anyhow	R
.	,

How	R
about	P
this	D
modification	N
:	,

Perfect	A
!	,
Works	V
as	P
needed	V
!	,

You	O
need	V
to	P
write	V
two	$
patterns	N
for	P
either	D
single	A
or	&
double	R
quoted	V
strings	N
,	,
as	P
there	X
is	V
no	D
way	N
to	P
make	V
the	D
regex	N
remember	V
which	O
opened	V
the	D
string	N
.	,
Then	R
you	O
can	V
or	&
them	O
together	R
with	P
|	G
.	,

Consider	V
using	V
code	N
from	P
Rhino	^
--	^
JS	^
in	P
Java	^
--	,
to	P
get	V
the	D
real	A
String	N
literals	^
.	,
Or	^
,	,
if	P
you	O
want	V
to	P
use	V
regex	N
,	,
consider	V
one	O
find	V
for	P
the	D
whole	A
literal	N
,	,
then	R
a	D
nested	V
test	N
if	P
the	D
literal	A
contains	N
'	,
keyword	^
'	,
.	,
I	O
think	V
Tim's	Z
construction	N
works	V
,	,
but	&
I	O
wouldn't	V
bet	V
on	P
it	O
in	P
all	D
situations	N
,	,
and	&
the	D
regex	N
would	V
have	V
to	P
get	V
insanely	R
unwieldy	A
if	P
it	O
had	V
to	P
deal	N
with	P
literals	V
that	O
don't	V
want	V
to	P
be	V
found	V
(	,
as	R
if	P
trying	V
to	P
sneak	V
by	P
your	D
testing	N
)	,
.	,
For	P
example	N
:	,
Separate	V
from	P
any	D
solution	N
,	,
my	D
secret	A
weapon	N
for	P
interactively	^
working	V
out	T
regexes	O
is	V
a	D
tool	N
I	O
made	V
called	V
Regex	^
Powertoy	^
,	,
which	O
unlike	P
many	A
such	A
utilities	N
runs	V
in	P
any	D
browser	N
with	P
Java	^
applet	N
support	N
.	,

The	D
test	N
case	N
you	O
mentioned	V
does	V
not	R
apply	V
to	P
my	D
situation	N
.	,
I'm	L
guaranteed	A
that	O
'	,
keyword	^
'	,
will	V
appear	V
just	R
like	P
that	O
,	,
in	P
ASCII	^
.	,
Doing	V
two	$
tests	N
(	,
first	A
test	N
for	P
string	V
literal	A
,	,
then	R
test	N
for	P
presence	N
of	P
keyword	^
)	,
will	V
produce	V
a	D
lot	N
of	P
false-positives	V
in	P
my	D
case	N
because	P
probability	N
of	P
a	D
literal	N
having	V
a	D
keyword	^
is	V
about	P
1%	$
.	,

Interesting	A
observation	N
.	,
Do	V
you	O
happen	V
to	P
have	V
a	D
test	N
case	N
that	O
will	V
break	V
Tim's	Z
solution	N
?	,
It	O
seems	V
to	P
be	V
holding	V
up	T
to	P
all	X
of	P
my	D
test	N
cases	N
.	,

