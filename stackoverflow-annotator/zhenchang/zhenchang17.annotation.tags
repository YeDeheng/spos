713276		Detecting EOF / TCP teardown using Java sockets from Javascript	V ^ , ^ N V ^ N P ^		Thu Sep 03 2015 15:13:45 GMT+0800 (Malay Peninsula Standard Time)
713276		I'm creating a Java socket in Javascript , sending an HTTP request and receiving a response correctly but I seem to be unable to detect an EOF or the server closing the socket at the end . What am I doing wrong ? The problem is we never exit the outermost while loop - the server stops transmitting and ( presumably ) closes its end of the connection , yet receiver.read() never returns -1 and all the socket methods return state consistent with the socket still being connected .	L V D ^ N P ^ , V D ^ N & V D N R & O V P V A P V D ^ & D N V D N P D N , O V O V A , D N V O R V D A ^ N , D N V V & , R , V D N P D N , & ^ R V $ & X D N N V N A P D N R V V ,		Thu Sep 03 2015 15:13:45 GMT+0800 (Malay Peninsula Standard Time)
713276	Tokenization Error	Wouldn't the this : while ( receiver.available() & & ! eof ) be better ? in lieu of the first while ( receiver.available() ) ?	V D D , ^ , ^ = = = ^ , V R , P O P D A ^ G ^ G ,		Thu Sep 03 2015 15:13:45 GMT+0800 (Malay Peninsula Standard Time)
713276		Seems a bit redundant - available() is defined as returning the number of bytes of data available to read without blocking , so would return 0 after EOF . Tried it anyway just in case ; doesn't fix the problem .	V D R A , ^ V V P V D N P V P N A P V P V , P V V $ P ^ , V O R R P N , V V D N ,		Thu Sep 03 2015 15:13:45 GMT+0800 (Malay Peninsula Standard Time)
713276		Or do you mean in place of the outermost while ? Data being available to read without blocking is independent of whether the server has closed the socket - there could be pauses in transmission , and the OS could have buffered input data . So we must test both separately .	& V O V P N P D A ^ , N V A P V P V V A P & D N V V D N , X V V N P N , & D ^ V V V N N , P O V V D R ,		Thu Sep 03 2015 15:13:45 GMT+0800 (Malay Peninsula Standard Time)
713276		No , I meant the inner while , but your first comment is right : I'm wrong .	N , O V D A ^ , & D A N V A , L A ,		Thu Sep 03 2015 15:13:45 GMT+0800 (Malay Peninsula Standard Time)
713276		Ok . What's the value of eof when the code reaches this comment ? // at this point response does contain the expected HTTP response What's the symptom ? I assume it's an infinite loop ?	N , L D N P ^ R D N V D N , = P D N N V V D V ^ N L D N , O V L D A N ,		Thu Sep 03 2015 15:13:45 GMT+0800 (Malay Peninsula Standard Time)
713276		eof is still 0 at that point ( otherwise we'd exit the outermost while() correctly and I'd not be posting this ) . Question edited - hopefully the problem is clearer now ?	^ V R $ P D N , R L V D A ^ R & L R V V D , , N V , R D N V A R ,		Thu Sep 03 2015 15:13:46 GMT+0800 (Malay Peninsula Standard Time)
713276		OK , further research suggests there is no non-blocking way to discover whether the remote side has closed a socket . However , it is possible to achieve this using NIO channels :	N , A N V R V D A N P V & D A N V V D N , R , O V A P V D V ^ N ,		Thu Sep 03 2015 15:13:46 GMT+0800 (Malay Peninsula Standard Time)
713276		When the end of the stream is reached , available() returns 0 , so in your code , you never read the -1	R D N P D N V V , ^ V $ , R P D N , O R V D $		Thu Sep 03 2015 15:13:46 GMT+0800 (Malay Peninsula Standard Time)
713276		Right . But read() will block until either EOF is reached or there is more data , and Javascript is single-threaded so we don't want to issue a read without knowing for certain we have data to read . And available() can return 0 during transmission , so we can't use that to test for EOF .	! , & ^ V N P & ^ V V & X V A N , & ^ V A P O V V P V N N P V P A O V N P V , & ^ V V $ P N , P O V V O P V P ^ ,		Thu Sep 03 2015 15:13:46 GMT+0800 (Malay Peninsula Standard Time)
