Difference	N
between	N
class	N
(	N
java	N
)	N
and	N
closure	N
(	N
javascript	N
)	N
?	N

I	N
don't	N
understand	N
how	N
closure	N
is	N
more	N
powerful	N
than	N
class	N
.	N
It	N
looks	N
like	N
I	N
can	N
achieve	N
the	N
same	N
behavior	N
of	N
closure	N
using	N
class	N
.	N
Any	N
help	N
would	N
be	N
appreciated	N

Can	N
you	N
provide	N
a	N
link	N
for	N
the	N
statement	N
that	N
one	N
or	N
the	N
other	N
paradigm	N
is	N
more	N
powerful	N
?	N
Please	N
also	N
define	N
what	N
you	N
mean	N
by	N
"	N
powerful	N
"	N
.	N

A	N
closure	N
and	N
a	N
class	N
are	N
two	N
very	N
different	N
things	N
.	N
It	N
is	N
not	N
correct	N
to	N
say	N
'	N
A	N
class	N
is	N
more	N
powerful	N
that	N
a	N
closure	N
.	N
'	N
or	N
vise	N
a	N
versa	N
.	N
They	N
do	N
totally	N
different	N
things	N
.	N
A	N
closure	N
is	N
in	N
a	N
basic	N
sense	N
,	N
a	N
function	N
call	N
that	N
retains	N
the	N
local	N
variable	N
information	N
from	N
the	N
scope	N
it	N
was	N
created	N
.	N
A	N
class	N
is	N
a	N
definition	N
of	N
an	N
object	N
.	N
The	N
class	N
defines	N
behavior	N
and	N
the	N
contents	N
of	N
instances	N
of	N
the	N
class	N
.	N

Doesn't	N
a	N
closure	N
retain	N
the	N
variables	N
from	N
the	N
scope	N
in	N
which	N
it's	N
declared	N
?	N
(	N
not	N
called	N
,	N
necessarily	N
)	N

oops	N
.	N
thanks	N
.	N

and	N
it	N
should	N
be	N
mentioned	N
that	N
javascript	N
has	N
a	N
prototype	N
system	N

I'm	N
not	N
sure	N
what	N
led	N
you	N
to	N
this	N
question	N
,	N
but	N
something	N
you've	N
been	N
told	N
or	N
something	N
you	N
read	N
has	N
severely	N
misled	N
you	N
.	N
Ignoring	N
language	N
altogether	N
,	N
a	N
closure	N
and	N
a	N
class	N
are	N
completely	N
unrelated	N
structures	N
/	N
conventions	N
in	N
programming	N
.	N

syntactically	N
may	N
be	N
,	N
but	N
you	N
can	N
emulate	N
one	N
with	N
the	N
other	N
in	N
java	N
for	N
example	N
,	N
and	N
they	N
are	N
not	N
tooo	N
different	N
from	N
each	N
other	N
when	N
you	N
start	N
thinking	N
about	N
it	N
.	N

Closures	N
are	N
poor	N
man's	N
objects	N
/	N
Objects	N
are	N
poor	N
man's	N
closure	N
Please	N
see	N
:	N
closures	N
and	N
objects	N
For	N
the	N
lazy	N
:	N
The	N
venerable	N
master	N
Qc	N
Na	N
was	N
walking	N
with	N
his	N
student	N
,	N
Anton	N
.	N
Hoping	N
to	N
prompt	N
the	N
master	N
into	N
a	N
discussion	N
,	N
Anton	N
said	N
"	N
Master	N
,	N
I	N
have	N
heard	N
that	N
objects	N
are	N
a	N
very	N
good	N
thing	N
-	N
is	N
this	N
true	N
?	N
"	N
Qc	N
Na	N
looked	N
pityingly	N
at	N
his	N
student	N
and	N
replied	N
,	N
"	N
Foolish	N
pupil	N
-	N
objects	N
are	N
merely	N
a	N
poor	N
man's	N
closures	N
.	N
"	N
Chastised	N
,	N
Anton	N
took	N
his	N
leave	N
from	N
his	N
master	N
and	N
returned	N
to	N
his	N
cell	N
,	N
intent	N
on	N
studying	N
closures	N
.	N
He	N
carefully	N
read	N
the	N
entire	N
"	N
Lambda	N
:	N
The	N
Ultimate	N
...	N
"	N
series	N
of	N
papers	N
and	N
its	N
cousins	N
,	N
and	N
implemented	N
a	N
small	N
Scheme	N
interpreter	N
with	N
a	N
closure-based	N
object	N
system	N
.	N
He	N
learned	N
much	N
,	N
and	N
looked	N
forward	N
to	N
informing	N
his	N
master	N
of	N
his	N
progress	N
.	N
On	N
his	N
next	N
walk	N
with	N
Qc	N
Na	N
,	N
Anton	N
attempted	N
to	N
impress	N
his	N
master	N
by	N
saying	N
"	N
Master	N
,	N
I	N
have	N
diligently	N
studied	N
the	N
matter	N
,	N
and	N
now	N
understand	N
that	N
objects	N
are	N
truly	N
a	N
poor	N
man's	N
closures	N
.	N
"	N
Qc	N
Na	N
responded	N
by	N
hitting	N
Anton	N
with	N
his	N
stick	N
,	N
saying	N
"	N
When	N
will	N
you	N
learn	N
?	N
Closures	N
are	N
a	N
poor	N
man's	N
object	N
.	N
"	N
At	N
that	N
moment	N
,	N
Anton	N
became	N
enlightened	N
.	N
Anton	N
van	N
Straaten	N

thank	N
you	N
for	N
the	N
koan	N
.	N

Will	N
I	N
become	N
enlightened	N
when	N
I	N
figure	N
out	N
how	N
to	N
pronounce	N
Qc	N
Na	N
?	N

It	N
sounds	N
like	N
one	N
hand	N
clapping	N
.	N

@Sebasti	N
nGrignoli	N
-	N
In	N
particular	N
,	N
one	N
that	N
is	N
applauding	N
the	N
felling	N
of	N
a	N
tree	N
in	N
a	N
vacant	N
forest	N
.	N

The	N
differences	N
between	N
a	N
class	N
and	N
a	N
closure	N
have	N
been	N
explained	N
by	N
others	N
already	N
.	N
I	N
just	N
wanted	N
to	N
point	N
out	N
that	N
in	N
many	N
places	N
in	N
the	N
Java	N
API	N
where	N
a	N
language	N
that	N
supported	N
them	N
would	N
/	N
could	N
use	N
closures	N
,	N
an	N
anonymous	N
implementation	N
of	N
an	N
interface	N
is	N
used	N
.	N
For	N
instance	N
consider	N
the	N
code	N
below	N
:	N
In	N
this	N
case	N
the	N
anonymous	N
ActionListener	N
could	N
be	N
said	N
to	N
be	N
acting	N
as	N
a	N
closure	N
,	N
if	N
Java	N
allowed	N
closures	N
,	N
the	N
code	N
might	N
look	N
like	N
this	N
:	N
(	N
using	N
c++0x-esque	N
syntax	N
)	N
In	N
this	N
trivial	N
case	N
,	N
the	N
main	N
difference	N
between	N
a	N
closure	N
and	N
an	N
anonymous	N
implementation	N
of	N
an	N
interface	N
(	N
AII	N
)	N
is	N
that	N
:	N
The	N
AII	N
method	N
has	N
stronger	N
type	N
checking	N
than	N
a	N
closure	N
.	N
(	N
Closure	N
systems	N
can	N
be	N
made	N
to	N
have	N
stronger	N
type	N
checking	N
,	N
but	N
in	N
general	N
,	N
they	N
aren't	N
)	N
The	N
closure	N
syntax	N
requires	N
less	N
typing	N
.	N
This	N
seems	N
to	N
be	N
the	N
main	N
gripe	N
that	N
renders	N
out	N
once	N
you	N
chew	N
on	N
the	N
Java	N
need	N
closures	N
arguments	N
long	N
enough	N
.	N
I	N
have	N
yet	N
to	N
run	N
into	N
a	N
situation	N
where	N
AII	N
can't	N
do	N
what	N
needs	N
doing	N
.	N
Yes	N
,	N
there	N
is	N
more	N
typing	N
and	N
another	N
interface	N
to	N
define	N
,	N
but	N
they	N
system	N
works	N
and	N
is	N
,	N
IMHO	N
,	N
more	N
powerful	N
since	N
you	N
needn't	N
use	N
an	N
AII	N
but	N
rather	N
can	N
use	N
a	N
full-fledged	N
class	N
with	N
it's	N
own	N
methods	N
,	N
member	N
data	N
,	N
and	N
constructor	N
.	N
An	N
example	N
is	N
an	N
action	N
listener	N
that	N
pops	N
up	N
a	N
context	N
menu	N
.	N
If	N
you	N
make	N
a	N
class	N
that	N
implements	N
ActionListener	N
and	N
takes	N
a	N
JMenu	N
as	N
it's	N
argument	N
,	N
you	N
can	N
do	N
:	N
This	N
looks	N
cleaner	N
(	N
to	N
me	N
)	N
than	N
a	N
boost	N
:b	N
ind	N
type	N
solution	N
.	N
or	N
so	N
EDIT	N
:	N
After	N
doing	N
a	N
lot	N
of	N
work	N
last	N
night	N
messing	N
with	N
generics	N
,	N
I	N
realized	N
one	N
advantage	N
of	N
closures	N
over	N
AII	N
.	N
In	N
the	N
above	N
examples	N
,	N
I	N
have	N
been	N
assuming	N
that	N
the	N
closure	N
would	N
be	N
of	N
type	N
[	N
]=	N
>	N
(	N
ActionEvent	N
)	N
,	N
but	N
it	N
really	N
could	N
be	N
of	N
the	N
type	N
[	N
]=	N
>	N
(	N
?	N
super	N
ActionEvent	N
)	N
.	N
This	N
means	N
:	N
Would	N
be	N
compilable	N
.	N
This	N
could	N
prove	N
useful	N
,	N
for	N
when	N
you	N
need	N
to	N
do	N
the	N
same	N
thing	N
in	N
response	N
to	N
multiple	N
events	N
.	N
Another	N
example	N
.	N
This	N
closure	N
could	N
be	N
added	N
to	N
any	N
place	N
that	N
takes	N
a	N
closure	N
.	N
If	N
added	N
to	N
something	N
as	N
an	N
ActionListener	N
or	N
MouseListener	N
,	N
it	N
would	N
log	N
calls	N
.	N

This	N
is	N
a	N
good	N
question	N
but	N
could	N
be	N
better	N
worded	N
:	N
"	N
What	N
are	N
some	N
similarities	N
and	N
differences	N
between	N
Java	N
objects	N
and	N
JavaScript	N
closures	N
"	N
?	N
Similarities	N
:	N
they	N
both	N
have	N
persistent	N
state	N
in	N
their	N
local	N
variables	N
.	N
Their	N
methods	N
have	N
access	N
to	N
those	N
state	N
variables	N
.	N
Differences	N
:	N
Javascript	N
is	N
a	N
functional	N
language	N
,	N
therefore	N
functions	N
within	N
functions	N
can	N
be	N
immediately	N
invoked	N
and	N
returned	N
.	N
For	N
example	N
:	N
So	N
you	N
can	N
write	N
code	N
like	N
this	N
snippet	N
copy	N
/	N
pasted	N
from	N
rhino	N
shell	N
:	N

