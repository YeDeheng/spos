Do_V Applet_G JSObject_G javascript_N calls_N serialize_V ?_.
Do_V applet_N javascript_N calls_N serialize_V in_P any_D proper_A way_N ?_. I'm_N considering_V implementing_V a_D model_N in_P which_D two_$ threads_N send_V off_R javascript_N commands_N ._. One_$ responds_V to_P requests_N from_P the_D browser_N (_G js_G )_N ,_, and_& the_D other_A hits_N the_D browser_N periodically_R ._. My_D question_N is_V this_D :_: what_O happens_V if_P these_D two_$ javascript_N requests_N collide_V ?_. I'm_N worried_V about_P concurrent_A javascript_N requests_N ,_, as_P intuition_N leads_V me_O to_P believe_V that_P one_$ of_P the_D calls_N will_V fail_V nondeterministically_R ._.
Javascript_^ is_V single-threaded_A ._. Only_R one_$ block_N of_P code_N can_V be_V executing_V at_P any_D given_V time_N ;_: any_D other_A event_N ,_, method_N ,_, etc_G ._. that_P fires_N will_V wait_V until_P the_D currently_R executing_V code_N terminates_V ._. Google_^ Chrome's_^ javascript_N engine_N may_V be_V an_D exception_N -_: I_O recall_V them_O mentioning_V some_D kind_N of_P multi-threaded_A javascript_N support_N in_P their_D features_N ,_, but_& I'm_N unsure_A how_R it_O works_V ._. In_P IE_N 6_$ ,_, the_D browser_N UI_^ will_V actually_R become_V unresponsive_A while_P JS_N code_N is_V running_V (_$ if_P you_O stop_V at_P a_D breakpoint_N with_P keyword_N '_'' debugger_N '_'' ,_, or_& have_V IE_N set_V to_P debug_V ,_, for_P example_N )_N ._.
Serialize_V ?_. Do_V you_O mean_V synchronize_V ?_. JSObject_N works_V by_P passing_V primitives_N to_P a_D single_A JSContext_N JNI_^ NPAPI_^ wrapper_N which_D acts_V on_P the_D DOM_^ in_P the_D underlying_A browser_N implementation_N ._. Are_V you_O referring_V to_P the_D passing_N of_P primitives_N through_P JNI_^ ?_. I_O don't_V know_V much_R about_P how_R chrome's_^ JS_^ engine_N works_V ,_, but_& I_O assume_V that_P since_P the_D liveconnect_A NPAPI_N in_P chrome_N is_V the_D same_A as_P the_D others_N ,_, the_D ability_N to_P write_V multithreaded_A javascript_N has_V nothing_N to_P do_V with_P multithreaded_A JSObject_N access_N ._. The_D affected_V code_N extends_V the_D same_A abstract_A JSObject_N class_N that_P firefox_N uses_V ._. There_X are_V several_A implementations_N of_P JSObject_N /_: liveconnect_N --_: a_D few_A for_P netscape_N /_: firefox_N and_& one_$ for_P ie_G (_G ocx_G )_G ._. All_D behave_V differently_R as_R far_R as_P multiple_A threads_N go_V ._. DOM_N access_N isn't_N threadsafe_N in_P general_A as_R far_R as_P liveconnect_N is_V concerned_V ._. So_R ,_, officially_R ,_, multiple_A threads_N accessing_V the_D DOM_^ is_V undefined_A ._. If_P you_O manage_V to_P actually_R access_V the_D DOM_N through_P something_N other_A than_P code_N scoped_V in_P DOMService.run()_N ,_, you'll_N get_V crazy_A deadlocks_N and_& race_N conditions_N ._. So_R ,_, basically_R ,_, you_O need_V all_D of_P your_D java_N threads_N to_P post_V all_D DOMActions_N to_P your_D DOM_^ access_N dispatch_V thread_N only_R ._.
