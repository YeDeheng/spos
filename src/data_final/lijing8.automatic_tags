421419	Good choice for a lightweight checksum algorithm ?	A N P D A N N ,
421419	So the whole TCP / IP checksum thing isn't working ... I'm thinking that anything corrupted in transit is going to get rejected at a much lower layer than the application level .	P D A N , ^ ^ N V V , L V D N V P N V V P V V P D R A N P D N N ,
421419	Yeah , this sounds like something usually left to the transport layer . Can you explain your scenario a little more ? Where is your data being sent and what specific causes of data corruption are you trying to guard against ?	! , O V P N R V P D N N , V O V D N D A A , R V D N V V & D A N P N N V O V P V P ,
421419	@dtsazza - you mentioned in a comment below that this is for security ( malicious users ) . Can you elaborate ? Especially since this will probably run in a browser .	@ ~ O V P D N P D D V P N , A N , , V O V , R P D V R V P D N ,
421419	Use SHA-1 JS implementation . It's not as slow as you think ( Firefox 3.0 on Core 2 Duo 2.4 Ghz hashes over 100KB per second ) .	V ^ ^ N , L R R A P O V , ^ $ P ^ P ^ ^ ^ V P $ P A , ,
421419	[ UPDATE 30 / 5 / 2013 : The link to the old JS CRC32 implementation died , so I've now linked to a different one . ] Google CRC32 : fast , and much lighter weight than MD5 et al . There is a Javascript implementation here .	, ^ $ , $ , @ , D N P D A ^ ^ N V , P L R V P D A $ , , ^ ^ , R , & R A N P ^ & N , X V D N N R ,
421419	Link now broken unfortunately .	V R V R ,
421419	@JamesWestgate : Thanks James , I've found a new one and linked to that . Incidentally the first JS version I found ( at http://noteslog.com/post/crc32-for-javascript/) actually reparses part of the string containing the table for each character processed , which will make it * much * slower than necessary .	@ ~ ^ ^ , L V D A $ & V P D , ^ D A N N O V , P U R A N P D N V D N P D N V , O V V O , A , A P A ,
421419	Awesome ! Thanks :) Looking for something to checksum javascript functions for a browser based animation code generation tool .	A , ! E V P N P ^ A N P D N V N N N N ,
421419	CRC32 is not too hard to implement in any language , it is good enough to detect simple data corruption and when implemted in a good fashion , it is very fast . However you can also try Adler32 , which is almost equally good as CRC32 , but it's even easier to implement ( and about equally fast ) . Adler32 in the Wikipedia CRC32 JavaScript implementation sample Either of these two ( or maybe even both ) are available in Java right out of the box .	^ V R R R P V P D N , O V A A P V A N N & R V P D A N , O V R R , R O V R V ^ , O V R R A P ^ , & L R A P V , & P R R , , ^ P D ^ ^ ^ N N ^ P D $ , & R R $ , V A P ^ R R P D N ,
421419	CRC32 , definitely was designed to be exactly what you describe .	^ , R V V P V R O O V ,
421419	A word of caution : the JavaScript in the link implements the algorithm with a table[256 ] of literal values . If you should modify even a single digit of that table , you will have a nasty bug that is very , very , hard to find ! I prefer implementations that generate the table on the 1st call .	D N P N , D N P D N V D N P D $ , P A N , P O V V R D A N P D N , O V V D A N P V R , R , R P V , O V P O V D N P D $ N ,
421419	I'll second @D .i.S's comment . Testability is a minus .	L A @ L V , N V D P ,
421419	Javascript implementation of MD4 , MD5 and SHA1 . BSD license .	A N P ^ , $ & ^ , ^ N ,
421419	Are aware that both TCP and UDP ( and IP , and Ethernet , and ... ) already provide checksum protection to data in transit ? Unless you're doing something really weird , if you're seeing corruption , something is very wrong . I suggest starting with a memory tester . Also , you receive strong data integrity protection if you use SSL / TLS .	V A P D ^ & N , & ^ , & N , & ~ , R V A N P N P N , P L V N R A , P L V N , N V R A , O V V P D N N , R , O V A N N N P O V ^ , ^ ,
421419	Yes , I am was aware of that , though you were right to point it out . Unfortunately it's in input coming from the world at large , so we need to be able to cope with this anyway ( malicious / mischevious users could mangle this for example ) .	! , O V V A P O , P O V R P N O T , R L P N V P D N P A , P O V P V A P V P D R , A , A N V P D P N , ,
421419	It might be worth pointing out that for any change-detection algorithm , there is always a chance that it won't detect an error . They all can have collisions or false-negatives , though usually the more expensive algorithms reduce this chance to near-astronomically small probabilities .	O V V V V T O P D N N , X V R D N P O V V D N , O X V V N & N , P R D R A N V D N P R A N ,
421419	@dtsazza : I wonder about the malicious / mischievous users who can mangle packets going across the network , but can't defeat Javascript . Or Adler32 .	@ ~ O V P D A , A N O V A N V P D N , & V ^ ^ , ^ ^ ,
421419	Other people have mentioned CRC32 already , but here's a link to the W3C implementation of CRC-32 for PNG , as one of the few well-known , reputable sites with a reference CRC implementation . ( A few years back I tried to find a well-known site with a CRC algorithm or at least one that cited the source for its algorithm , was almost tearing my hair out until I found the PNG page . )	A N V V ^ R , & L D N P D ^ N P ^ P ^ , P $ P D A N , A N P D N N N , , D A N R O V P V D A N P D ^ ^ & P R $ O V D N P D N , V R V D N P P O V D N N , E
421419	Here's a relatively simple one I've ' invented ' - there's no mathematical research behind it but it's extremely fast and works in practice . I've also included the Java equivalent that tests the algorithm and shows that there's less than 1 in 10,000,000 chance of failure ( it takes a minute or two to run ) . JavaScript Java	L D R A $ ^ , V , , Y D A N P O & L R R & V P N , L R V D ^ N O V D N & V D Z A P $ P $ N P N , O V D N & $ P V , , ^ ^
421419	Why ? Would you like to share an example ?	R , V O V P V D N ,
421419	This is a rather old thread but I suspect it is still viewed quite often so - if all you need is a short but reliable piece of code to generate a checksum the Adler32 bit algorithm has to be your choice . Here is the JavaScript code The corresponding fiddle demonsrating the algorithm in action is here .	D V D R A N & O V O V R V R R R , P X O V V D A & A N P N P V D G D ^ N N V P V D N , R V D N N ^ A N V D N P N V R ,
