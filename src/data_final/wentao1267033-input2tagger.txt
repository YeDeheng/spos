Kill	N
Java	N
Applet	N
via	N
Javascript	N

I	N
am	N
working	N
for	N
a	N
developing	N
firm	N
and	N
am	N
doing	N
a	N
major	N
redesign	N
on	N
a	N
Web	N
Application	N
,	N
which	N
reloaded	N
everything	N
after	N
each	N
click	N
,	N
to	N
make	N
extensive	N
use	N
of	N
Javascript	N
,	N
so	N
it	N
actually	N
feels	N
like	N
a	N
real	N
Web	N
application	N
.	N
One	N
of	N
the	N
Features	N
is	N
to	N
use	N
a	N
web-based	N
Painter	N
(	N
think	N
of	N
MSPaint	N
on	N
the	N
Web	N
)	N
,	N
which	N
I	N
embed	N
on	N
the	N
Page	N
on	N
Demand	N
.	N
After	N
the	N
image	N
is	N
painted	N
and	N
uploaded	N
,	N
the	N
Web-app	N
then	N
unloads	N
the	N
applet	N
and	N
proceeds	N
to	N
show	N
the	N
directory	N
where	N
the	N
file	N
was	N
uploaded	N
to	N
.	N
This	N
is	N
where	N
Trouble	N
starts	N
.	N
It	N
all	N
works	N
on	N
IE	N
and	N
Safari	N
,	N
but	N
not	N
on	N
Firefox	N
3.5	N
(	N
3.0	N
works	N
perfectly	N
though	N
)	N
.	N
Firebug	N
tells	N
me	N
that	N
the	N
expando	N
property	N
is	N
missing	N
.	N
The	N
Web-app	N
Tiparlo	N
which	N
I	N
was	N
working	N
on	N
before	N
had	N
a	N
similar	N
Problem	N
(	N
in	N
fact	N
,	N
any	N
manipulation	N
done	N
on	N
an	N
applet	N
via	N
jQuery	N
is	N
faulty	N
)	N
but	N
solved	N
that	N
Problem	N
by	N
wrapping	N
a	N
div	N
around	N
and	N
controlling	N
(	N
hide	N
and	N
show	N
)	N
the	N
div	N
instead	N
of	N
the	N
applet	N
.	N
This	N
,	N
unfortunately	N
isn't	N
applicable	N
on	N
this	N
Web-app	N
,	N
because	N
the	N
Applet	N
has	N
to	N
be	N
destroyed	N
and	N
not	N
just	N
hidden	N
and	N
shown	N
,	N
as	N
it	N
takes	N
up	N
too	N
much	N
resources	N
to	N
be	N
run	N
the	N
entire	N
time	N
where	N
it	N
is	N
not	N
needed	N
.	N
To	N
make	N
it	N
short	N
:	N
Is	N
it	N
possible	N
to	N
make	N
an	N
Applet	N
destroy	N
itself	N
via	N
Javascript	N
?	N
Alternatively	N
:	N
Is	N
there	N
a	N
workaround	N
on	N
the	N
jQuery	N
/	N
expando	N
/	N
applet	N
problem	N
?	N
I	N
know	N
that	N
applet	N
is	N
deprecated	N
in	N
HTML	N
4.01	N
strict	N
but	N
changing	N
it	N
to	N
object	N
is	N
not	N
an	N
option	N
right	N
now	N
.	N
EDIT	N
:	N
I	N
have	N
added	N
a	N
Picture	N
of	N
Firefox	N
+	N
Firebug	N
to	N
show	N
you	N
the	N
actual	N
Error	N
Message	N
.	N
Posting	N
Code	N
does	N
no	N
god	N
,	N
since	N
it	N
works	N
flawless	N
on	N
every	N
other	N
Browser	N
and	N
is	N
a	N
Firefox	N
3.5	N
specific	N
Problem	N
.	N
Here	N
be	N
pictures	N
Note	N
:	N
You	N
can	N
ignore	N
the	N
JS	N
Bug	N
coming	N
from	N
button.js	N
.	N

What	N
happens	N
if	N
you	N
destroy	N
the	N
DIV	N
that	N
surrounds	N
the	N
applet	N
?	N
(	N
not	N
hide	N
it	N
,	N
destroy	N
it	N
with	N
removeElement	N
and	N
delete	N

I	N
tried	N
that	N
,	N
but	N
to	N
no	N
avail	N
.	N
My	N
Theory	N
:	N
I	N
imagine	N
that	N
by	N
hiding	N
the	N
parent	N
div	N
,	N
the	N
Browser	N
itself	N
takes	N
care	N
of	N
hiding	N
the	N
children	N
too	N
and	N
not	N
Javascript	N
.	N
But	N
,	N
when	N
deleting	N
the	N
parent	N
div	N
,	N
it	N
is	N
also	N
Javascript's	N
Job	N
to	N
delete	N
the	N
child	N
applet	N
hence	N
causing	N
the	N
expando	N
Bug	N
to	N
arise	N
.	N
I	N
have	N
been	N
looking	N
at	N
the	N
jQuery	N
Bug	N
Tracker	N
and	N
that	N
particular	N
Bug	N
is	N
listed	N
on	N
the	N
Roadmap	N
for	N
the	N
1.3	N
.	N
3	N
release	N
.	N
Since	N
I	N
cannot	N
wait	N
for	N
it	N
to	N
fix	N
itself	N
(	N
be	N
fixed	N
by	N
jQuery	N
dev	N
Team	N
)	N
,	N
I	N
have	N
to	N
find	N
a	N
workaround	N
.	N

I	N
would	N
suggest	N
that	N
you	N
create	N
a	N
class	N
that	N
monitors	N
the	N
applet	N
to	N
be	N
killed	N
.	N
run	N
the	N
monitor	N
as	N
some	N
sort	N
of	N
servlet	N
and	N
get	N
javascript	N
to	N
post	N
'	N
kill	N
applet	N
'	N
commands	N
when	N
it	N
needs	N
to	N
be	N
killed	N
.	N

You	N
could	N
always	N
load	N
the	N
applet	N
in	N
a	N
an	N
iframe	N
and	N
just	N
navigate	N
away	N
from	N
the	N
page	N
where	N
the	N
applet	N
is	N
loaded	N
.	N
This	N
will	N
kill	N
it	N
.	N
Your	N
other	N
option	N
if	N
you	N
want	N
to	N
call	N
the	N
destroy	N
from	N
javascript	N
would	N
be	N
to	N
put	N
something	N
like	N
this	N
in	N
.	N
This	N
is	N
not	N
a	N
nice	N
way	N
to	N
kill	N
an	N
applet	N
but	N
on	N
newer	N
browsers	N
it	N
does	N
not	N
throw	N
a	N
JS	N
error	N
,	N
on	N
older	N
ones	N
like	N
IE6	N
it	N
will	N
throw	N
a	N
js	N
error	N
.	N

Yep	N
,	N
this	N
one	N
solves	N
the	N
problem	N
(	N
generates	N
a	N
new	N
one	N
but	N
I	N
can	N
handle	N
that	N
one	N
)	N
.	N

What	N
was	N
the	N
new	N
problem	N
it	N
created	N
,	N
just	N
curious	N
.	N

If	N
you	N
kill	N
the	N
applet	N
after	N
the	N
javascript	N
call	N
finishes	N
it	N
will	N
probably	N
avoid	N
the	N
error	N
.	N
You	N
can	N
do	N
this	N
with	N
java.util.Timer.schedule()	N
.	N

why	N
not	N
use	N
the	N
nuilt	N
in	N
Applet's	N
stop()	N
method	N
?	N

