md5	$
hash	N
for	P
password	^
string	N
in	P
GWT	^
/	,
GWT-Ext	^
?	,

I	O
am	V
currently	R
trying	V
to	P
modify	V
an	D
existing	V
GWT-Ext	A
application	N
,	,
that	O
is	V
using	V
plain	A
text	N
passwords	N
in	P
its	D
MySql	^
database	N
.	,
My	D
plan	N
was	V
to	P
use	V
md5	$
hashes	N
,	,
as	P
the	D
existing	A
passwords	N
can	V
be	V
easily	R
altered	A
with	P
the	D
MySql	^
function	N
and	&
I	O
was	V
expecting	V
to	P
find	V
an	D
easy	A
solution	N
for	P
the	D
GWT-Ext	N
side	N
as	P
well	R
.	,
But	&
as	P
I	O
found	V
out	T
,	,
java.security	N
is	V
not	R
supported	V
by	P
GWT	^
and	&
there	R
doesn't	V
seem	V
to	P
be	V
any	D
other	A
implementation	N
that	P
can	V
be	V
used	V
to	P
change	V
the	D
password	N
string	N
to	P
a	D
md5	$
hash	N
on	P
client	N
side	N
.	,
Only	R
"	,
solution	N
"	,
I	O
found	V
so	R
far	R
,	,
is	V
to	P
re	N
implement	V
a	D
md5	$
method	N
via	P
JSNI	^
as	P
described	V
here	R
:	,
http://groups.google.com/group/Google-Web-Toolkit/browse_thread/thread/ad09475a9944c9f8	U
There	X
is	V
an	D
existing	A
user	N
extension	N
for	P
Ext-JS	^
,	,
but	&
I	O
couldn't	V
find	V
anything	N
for	P
GWT-Ext	^
:	,
http://extjs.com/forum/showthread.php?p=133516	U
Does	V
anybody	N
know	V
a	D
more	R
elegant	A
/	,
simple	A
way	N
to	P
solve	V
this	D
problem	N
?	,
Maybe	R
I	O
should	V
use	V
something	N
else	R
instead	R
of	P
md5	$
to	P
make	V
sure	A
the	D
passwords	N
are	V
encrypted	V
?	,
Cheers	^
Frank	^

Personally	R
,	,
I	O
would	V
say	V
you're	L
doing	V
it	O
wrong	A
.	,
I	O
wouldn't	V
hash	P
a	D
password	N
on	P
the	D
client	N
side	N
(	,
which	O
is	V
what	O
GWT	V
is	V
)	,
.	,
If	P
you	O
hash	V
your	D
password	N
,	,
you	O
will	V
undoubtedly	R
want	V
to	P
salt	N
it	O
,	,
otherwise	R
you	O
will	V
be	V
susceptible	A
to	P
rainbow	N
attacks	N
.	,
If	P
you	O
hash	N
+	&
salt	N
it	O
on	P
the	D
client	N
side	N
,	,
your	D
salt	N
will	V
be	V
accessible	A
to	P
your	D
users	N
.	,
If	P
I	O
were	V
you	O
,	,
I	O
would	V
hash	N
+	&
salt	N
your	D
password	N
on	P
the	D
server	N
side	N
.	,
This	D
will	V
allow	V
you	O
to	P
use	V
your	D
standard	A
Java	^
code	N
to	P
perform	V
your	D
MD5	^
hash	N
.	,
My	D
2	$
cents	N
.	,
-JP	V

Its	L
not	R
a	D
bad	A
scheme	N
if	P
he	O
does	V
something	N
like	P
cram-md5	$
on	P
the	D
client	N
side	N
,	,
where	R
the	D
client	N
computes	V
a	D
hmac	N
(	,
md5	$
hash	N
plus	&
a	D
nonce	N
salt	N
)	,
and	&
sends	V
it	O
to	P
the	D
server	N
.	,
The	D
down	T
side	N
is	V
that	P
the	D
server	N
needs	V
clear	A
text	N
password	N
to	P
check	V
the	D
hmac	N
.	,

good	A
point	N
about	P
the	D
rainbow	N
attacks	N
,	,
didn't	V
knew	V
about	P
this	D
before	R
.	,
I	O
also	R
solved	V
it	O
by	P
doing	V
the	D
encryption	N
on	P
the	D
server	N
side	N
,	,
but	&
the	D
idea	N
was	V
,	,
that	P
I	O
wanted	V
to	P
encrypt	V
the	D
password	N
,	,
before	P
sending	V
it	O
to	P
the	D
server	N
,	,
as	P
we	O
currently	R
only	A
use	N
http	U
and	&
no	D
https	N
.	,

GWT	O
is	V
client-side	A
and	&
server	N
side	N
.	,
Other	A
than	P
that	O
,	,
the	D
post	N
is	V
good	A
advice	N
.	,
Don't	V
hash	V
it	O
on	P
the	D
client	N
side	N
.	,
Have	V
a	D
look	V
at	P
http://www.owasp.org/index.php/Hashing_Java	U
.	,

Another	D
idea	N
that	P
may	V
fit	V
your	D
need	V
is	V
something	N
called	V
zero	$
knowledge	N
auth	N
.	,
(	,
Ie	^
.	,
the	D
server	N
never	R
needs	V
to	P
know	V
the	D
user's	Z
plain	A
text	N
password	N
.	,
)	,
Basically	R
,	,
when	O
setting	V
the	D
initial	N
password	N
,	,
the	D
client	N
hashes	V
the	D
user's	Z
password	^
N	^
times	^
(	,
where	R
N	&
is	V
a	D
largish	A
number	N
like	P
1000	$
)	,
,	,
and	&
then	R
sends	V
that	D
final	A
hash	N
to	P
the	D
server	N
along	P
with	P
N	^
.	,
The	D
server	N
stores	V
the	D
hash	N
and	&
N	N
.	,
Later	R
,	,
when	R
the	D
user	N
wants	V
to	P
authenticate	V
,	,
the	D
server	N
tells	V
the	D
client	N
N-1	^
,	,
and	&
the	D
client	N
hashes	V
the	D
password	^
the	D
user	N
types	N
N-1	^
times	^
and	&
sends	V
that	O
to	P
the	D
server	N
.	,
The	D
server	N
does	V
1	$
more	A
hash	N
on	P
the	D
received	A
hash	N
,	,
and	&
(	,
hopefully	R
)	,
gets	V
the	D
stored	A
hash	N
.	,
The	D
server	N
then	R
stores	V
the	D
N-1	^
hash	N
and	&
N-1	$
number	N
.	,
Each	D
time	N
the	D
user	N
authenticates	N
,	,
the	D
server	N
decrements	V
the	D
stored	V
N	N
and	&
saves	V
the	D
previous	A
hash	N
.	,
When	R
N	&
gets	V
down	T
to	P
0	$
,	,
the	D
user	N
must	V
choose	V
and	&
set	V
a	D
new	A
password	N
.	,
The	D
server	N
must	V
ensure	V
that	P
it	O
never	R
asks	V
for	P
the	D
same	A
iteration	N
,	,
otherwise	R
it	O
is	V
vulnerable	A
to	P
a	D
replay	N
.	,
You	O
can't	V
really	R
enforce	V
that	D
condition	N
from	P
the	D
client	N
side	N
because	P
the	D
client	N
(	,
especially	R
a	D
browser	N
)	,
can't	V
reliably	R
keep	V
track	N
of	P
the	D
last	A
N	N
.	,

Very	R
interesting	A
idea	N
,	,
and	&
never	R
thought	V
of	P
that	O
before	R
.	,
Doesn't	V
really	R
fit	V
in	P
the	D
current	A
solution	N
,	,
but	&
I	O
will	V
keep	V
it	O
in	P
mind	N
for	P
future	A
reference	N
,	,
thanks	!
:-)	E

Interesting	A
idea	N
so	P
I	O
spent	V
some	D
time	N
thinking	V
about	P
it	O
,	,
but	&
it	O
is	V
vulnerable	A
to	P
a	D
man-in-the-middle	A
attack	N
.	,
On	P
an	D
authentication	N
request	N
,	,
the	D
server	N
sends	V
some	D
number	N
M	N
.	,
The	D
attacker	N
sends	V
(	,
M-1	^
)	E
to	P
the	D
client	N
,	,
and	&
receives	V
hash	N
(	,
M-1	^
)	,
back	N
.	,
The	D
attacker	N
tries	V
to	P
authenticate	V
again	R
,	,
receives	V
challenge	N
(	,
M-1	^
)	,
from	P
the	D
server	N
and	&
responds	V
with	P
hash	N
(	,
M-1	^
)	E
.	,
The	D
attacker	N
is	V
now	R
authenticated	A
.	,

yes	!
,	,
that	O
does	V
sound	N
like	P
an	D
issue	N
.	,
My	D
first	R
thought	V
would	V
be	V
to	P
require	V
the	D
server	N
to	P
not	R
reuse	A
M	N
after	P
issuing	V
it	O
during	P
a	D
challenge	N
to	P
the	D
client	N
.	,
However	R
,	,
the	D
larger	A
issue	N
remains	V
that	D
Mallory	^
could	V
tell	V
the	D
client	N
M-100	$
,	,
collect	V
the	D
hash	N
(	,
M-100	E
)	E
from	P
the	D
client	N
,	,
and	&
then	R
login	V
up	T
to	P
100	$
times	N
with	P
the	D
intercepted	V
hash	N
.	,
I'll	L
have	V
to	P
go	V
see	V
if	P
the	D
project	N
that	P
I	O
first	R
encountered	V
this	D
in	P
found	V
the	D
same	A
issues	N
and	&
dealt	V
with	P
it	O
or	&
abandoned	A
zero	$
knowledge	N
auth	N
.	,

I	O
think	V
you're	L
always	R
going	V
to	P
be	V
vulnerable	A
to	P
a	D
man	N
in	P
the	D
middle	A
attack	N
.	,
Keyloggers	^
too	R
.	,
Also	R
drunken	A
confessions	N
of	P
passwords	N
.	,
We	O
can	V
only	R
raise	V
the	D
bar	N
so	R
far	R
with	P
reasonable	A
coding	N
efforts	N
.	,

You	O
can	V
use	V
gwt-crypto	A
to	P
generate	V
SHA-1	^
hashes	V
on	P
the	D
client	N
side	N
using	V
:	,

You	O
should	V
never	R
use	V
an	D
md5	$
or	&
other	A
hash	N
functions	N
for	P
password	^
encryption	N
.	,
See	V
http://codahale.com/how-to-safely-store-a-password	U
/	,

