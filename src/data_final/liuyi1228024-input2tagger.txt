Do	N
Applet	N
JSObject	N
javascript	N
calls	N
serialize	N
?	N

Do	N
applet	N
javascript	N
calls	N
serialize	N
in	N
any	N
proper	N
way	N
?	N
I'm	N
considering	N
implementing	N
a	N
model	N
in	N
which	N
two	N
threads	N
send	N
off	N
javascript	N
commands	N
.	N
One	N
responds	N
to	N
requests	N
from	N
the	N
browser	N
(	N
js	N
)	N
,	N
and	N
the	N
other	N
hits	N
the	N
browser	N
periodically	N
.	N
My	N
question	N
is	N
this	N
:	N
what	N
happens	N
if	N
these	N
two	N
javascript	N
requests	N
collide	N
?	N
I'm	N
worried	N
about	N
concurrent	N
javascript	N
requests	N
,	N
as	N
intuition	N
leads	N
me	N
to	N
believe	N
that	N
one	N
of	N
the	N
calls	N
will	N
fail	N
nondeterministically	N
.	N

Javascript	N
is	N
single-threaded	N
.	N
Only	N
one	N
block	N
of	N
code	N
can	N
be	N
executing	N
at	N
any	N
given	N
time	N
;	N
any	N
other	N
event	N
,	N
method	N
,	N
etc	N
.	N
that	N
fires	N
will	N
wait	N
until	N
the	N
currently	N
executing	N
code	N
terminates	N
.	N
Google	N
Chrome's	N
javascript	N
engine	N
may	N
be	N
an	N
exception	N
-	N
I	N
recall	N
them	N
mentioning	N
some	N
kind	N
of	N
multi-threaded	N
javascript	N
support	N
in	N
their	N
features	N
,	N
but	N
I'm	N
unsure	N
how	N
it	N
works	N
.	N
In	N
IE	N
6	N
,	N
the	N
browser	N
UI	N
will	N
actually	N
become	N
unresponsive	N
while	N
JS	N
code	N
is	N
running	N
(	N
if	N
you	N
stop	N
at	N
a	N
breakpoint	N
with	N
keyword	N
'	N
debugger	N
'	N
,	N
or	N
have	N
IE	N
set	N
to	N
debug	N
,	N
for	N
example	N
)	N
.	N

Serialize	N
?	N
Do	N
you	N
mean	N
synchronize	N
?	N
JSObject	N
works	N
by	N
passing	N
primitives	N
to	N
a	N
single	N
JSContext	N
JNI	N
NPAPI	N
wrapper	N
which	N
acts	N
on	N
the	N
DOM	N
in	N
the	N
underlying	N
browser	N
implementation	N
.	N
Are	N
you	N
referring	N
to	N
the	N
passing	N
of	N
primitives	N
through	N
JNI	N
?	N
I	N
don't	N
know	N
much	N
about	N
how	N
chrome's	N
JS	N
engine	N
works	N
,	N
but	N
I	N
assume	N
that	N
since	N
the	N
liveconnect	N
NPAPI	N
in	N
chrome	N
is	N
the	N
same	N
as	N
the	N
others	N
,	N
the	N
ability	N
to	N
write	N
multithreaded	N
javascript	N
has	N
nothing	N
to	N
do	N
with	N
multithreaded	N
JSObject	N
access	N
.	N
The	N
affected	N
code	N
extends	N
the	N
same	N
abstract	N
JSObject	N
class	N
that	N
firefox	N
uses	N
.	N
There	N
are	N
several	N
implementations	N
of	N
JSObject	N
/	N
liveconnect	N
--	N
a	N
few	N
for	N
netscape	N
/	N
firefox	N
and	N
one	N
for	N
ie	N
(	N
ocx	N
)	N
.	N
All	N
behave	N
differently	N
as	N
far	N
as	N
multiple	N
threads	N
go	N
.	N
DOM	N
access	N
isn't	N
threadsafe	N
in	N
general	N
as	N
far	N
as	N
liveconnect	N
is	N
concerned	N
.	N
So	N
,	N
officially	N
,	N
multiple	N
threads	N
accessing	N
the	N
DOM	N
is	N
undefined	N
.	N
If	N
you	N
manage	N
to	N
actually	N
access	N
the	N
DOM	N
through	N
something	N
other	N
than	N
code	N
scoped	N
in	N
DOMService.run()	N
,	N
you'll	N
get	N
crazy	N
deadlocks	N
and	N
race	N
conditions	N
.	N
So	N
,	N
basically	N
,	N
you	N
need	N
all	N
of	N
your	N
java	N
threads	N
to	N
post	N
all	N
DOMActions	N
to	N
your	N
DOM	N
access	N
dispatch	N
thread	N
only	N
.	N

