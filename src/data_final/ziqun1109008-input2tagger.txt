Regexp	N
to	N
match	N
Javascript	N
string	N
literals	N
with	N
a	N
specific	N
keyword	N
using	N
Java	N

I'm	N
trying	N
to	N
match	N
chunks	N
of	N
JS	N
code	N
and	N
extract	N
string	N
literals	N
that	N
contain	N
a	N
given	N
keyword	N
using	N
Java	N
.	N
After	N
trying	N
to	N
come	N
up	N
with	N
my	N
own	N
regexp	N
to	N
do	N
this	N
,	N
I	N
ended	N
up	N
modifying	N
this	N
generalized	N
string-literal	N
matching	N
regexp	N
(	N
Pattern.COMMENTS	N
used	N
when	N
building	N
the	N
patterns	N
in	N
Java	N
):	N
(	N
[	N
"'	N
]	N
)	N
(	N
?	N
:\	N
\	N
?	N
+	N
.	N
)	N
*	N
?	N
\1	N
to	N
the	N
following	N
(	N
[	N
"'	N
]	N
)	N
(	N
?	N
:\	N
\	N
?	N
+	N
.	N
)	N
*	N
?	N
keyword	N
(	N
?	N
:\	N
\	N
?	N
+	N
.	N
)	N
*	N
?	N
\1	N
The	N
test	N
cases	N
:	N
The	N
regexp	N
correctly	N
doesn't	N
match	N
line	N
1	N
and	N
correctly	N
matches	N
line	N
2	N
.	N
However	N
,	N
in	N
line	N
3	N
,	N
instead	N
of	N
just	N
matching	N
"	N
testkeyword	N
"	N
,	N
it	N
matches	N
the	N
chunk	N
which	N
is	N
wrong	N
-	N
the	N
regexp	N
matched	N
the	N
first	N
double	N
quote	N
and	N
did	N
not	N
terminate	N
at	N
the	N
second	N
double	N
quote	N
,	N
going	N
all	N
the	N
way	N
till	N
the	N
end	N
of	N
line	N
.	N
Does	N
anyone	N
have	N
any	N
ideas	N
on	N
how	N
to	N
fix	N
this	N
?	N
PS	N
:	N
Please	N
keep	N
in	N
mind	N
that	N
the	N
Regexp	N
has	N
to	N
correctly	N
handle	N
escaped	N
single	N
and	N
double	N
quote	N
characters	N
inside	N
of	N
string	N
literals	N
(	N
which	N
the	N
generalized	N
matcher	N
already	N
did	N
)	N
.	N

After	N
much	N
revision	N
(	N
see	N
edit	N
history	N
,	N
viewers	N
at	N
home	N
:)	N
,	N
I	N
believe	N
this	N
is	N
my	N
final	N
answer	N
:	N

It	N
does	N
when	N
I	N
test	N
it	N
...	N
test	N
case	N
3	N
matches	N
properly	N
as	N
2	N
string	N
literals	N
.	N
Here	N
is	N
where	N
the	N
original	N
regex	N
came	N
from	N
http://blog.stevenlevithan.com/archives/match-quoted-string	N

Oops	N
,	N
I	N
see	N
.	N
Yeah	N
,	N
it's	N
relying	N
on	N
the	N
non-greedy	N
behavior	N
for	N
that	N
,	N
which	N
you	N
can't	N
use	N
the	N
same	N
way	N
because	N
you're	N
anchoring	N
to	N
a	N
keyword	N
.	N
Editing	N
...	N

That	N
should	N
work	N
but	N
the	N
problem	N
in	N
my	N
case	N
would	N
be	N
false-positives	N
.	N
The	N
probability	N
of	N
a	N
string	N
literal	N
having	N
the	N
special	N
keyword	N
is	N
about	N
1%	N
.	N
And	N
I	N
have	N
to	N
process	N
a	N
lot	N
of	N
files	N
with	N
hundreds	N
of	N
lines	N
every	N
time	N
.	N
If	N
no	N
one	N
can	N
come	N
up	N
with	N
a	N
way	N
to	N
pre-screen	N
the	N
literals	N
for	N
the	N
special	N
keyword	N
before	N
processing	N
them	N
,	N
I'll	N
go	N
with	N
your	N
solution	N
.	N

Maybe	N
further	N
developments	N
will	N
help	N
...	N

It	N
seems	N
to	N
match	N
a	N
lot	N
more	N
than	N
needed	N
.	N
In	N
my	N
test	N
case	N
chunk	N
above	N
,	N
it	N
matched	N
:	N
"	N
test	N
"	N
;	N
var	N
v2	N
=	N
"	N
testkeyword	N
"	N
;	N
var	N
v3	N
=	N
"	N
test	N
"	N
;	N
var	N
v4	N
=	N
"	N
testkeyword	N
"	N
;	N

Tim's	N
modification	N
of	N
your	N
Regexp	N
above	N
works	N
correctly	N
.	N

Cool	N
.	N
Glad	N
to	N
have	N
helped	N
,	N
anyhow	N
.	N

How	N
about	N
this	N
modification	N
:	N

Perfect	N
!	N
Works	N
as	N
needed	N
!	N

You	N
need	N
to	N
write	N
two	N
patterns	N
for	N
either	N
single	N
or	N
double	N
quoted	N
strings	N
,	N
as	N
there	N
is	N
no	N
way	N
to	N
make	N
the	N
regex	N
remember	N
which	N
opened	N
the	N
string	N
.	N
Then	N
you	N
can	N
or	N
them	N
together	N
with	N
|	N
.	N

Consider	N
using	N
code	N
from	N
Rhino	N
--	N
JS	N
in	N
Java	N
--	N
to	N
get	N
the	N
real	N
String	N
literals	N
.	N
Or	N
,	N
if	N
you	N
want	N
to	N
use	N
regex	N
,	N
consider	N
one	N
find	N
for	N
the	N
whole	N
literal	N
,	N
then	N
a	N
nested	N
test	N
if	N
the	N
literal	N
contains	N
'	N
keyword	N
'	N
.	N
I	N
think	N
Tim's	N
construction	N
works	N
,	N
but	N
I	N
wouldn't	N
bet	N
on	N
it	N
in	N
all	N
situations	N
,	N
and	N
the	N
regex	N
would	N
have	N
to	N
get	N
insanely	N
unwieldy	N
if	N
it	N
had	N
to	N
deal	N
with	N
literals	N
that	N
don't	N
want	N
to	N
be	N
found	N
(	N
as	N
if	N
trying	N
to	N
sneak	N
by	N
your	N
testing	N
)	N
.	N
For	N
example	N
:	N
Separate	N
from	N
any	N
solution	N
,	N
my	N
secret	N
weapon	N
for	N
interactively	N
working	N
out	N
regexes	N
is	N
a	N
tool	N
I	N
made	N
called	N
Regex	N
Powertoy	N
,	N
which	N
unlike	N
many	N
such	N
utilities	N
runs	N
in	N
any	N
browser	N
with	N
Java	N
applet	N
support	N
.	N

The	N
test	N
case	N
you	N
mentioned	N
does	N
not	N
apply	N
to	N
my	N
situation	N
.	N
I'm	N
guaranteed	N
that	N
'	N
keyword	N
'	N
will	N
appear	N
just	N
like	N
that	N
,	N
in	N
ASCII	N
.	N
Doing	N
two	N
tests	N
(	N
first	N
test	N
for	N
string	N
literal	N
,	N
then	N
test	N
for	N
presence	N
of	N
keyword	N
)	N
will	N
produce	N
a	N
lot	N
of	N
false-positives	N
in	N
my	N
case	N
because	N
probability	N
of	N
a	N
literal	N
having	N
a	N
keyword	N
is	N
about	N
1%	N
.	N

A	N
grammar	N
to	N
construct	N
a	N
string	N
literal	N
would	N
look	N
roughly	N
like	N
this	N
:	N
string-literal	N
::	N
=	N
quote	N
text	N
quote	N
text	N
::	N
=	N
character	N
text	N
|	N
character	N
character	N
::	N
=	N
non-quote	N
|	N
backslash	N
quote	N
with	N
non-quote	N
,	N
backslash	N
,	N
and	N
quote	N
being	N
terminals	N
.	N
A	N
grammar	N
is	N
regular	N
if	N
it	N
is	N
context	N
free	N
(	N
i.e.	N
the	N
left	N
hand	N
side	N
of	N
all	N
rules	N
is	N
always	N
a	N
single	N
non-terminal	N
)	N
and	N
the	N
right	N
hand	N
side	N
of	N
all	N
rules	N
is	N
always	N
either	N
empty	N
,	N
a	N
terminal	N
,	N
or	N
a	N
terminal	N
followed	N
by	N
a	N
non-terminal	N
.	N
You	N
may	N
notice	N
that	N
the	N
first	N
rule	N
given	N
above	N
has	N
a	N
terminal	N
followed	N
by	N
a	N
nonterminal	N
followed	N
by	N
a	N
terminal	N
.	N
This	N
is	N
thus	N
not	N
a	N
regular	N
grammar	N
.	N
A	N
regular	N
expression	N
is	N
an	N
expression	N
that	N
can	N
parse	N
regular	N
languages	N
(	N
languages	N
that	N
can	N
be	N
constructed	N
by	N
a	N
regular	N
grammar	N
)	N
.	N
It	N
is	N
not	N
possible	N
to	N
parse	N
non-regular	N
languages	N
with	N
regular	N
expressions	N
.	N
The	N
difficulty	N
you	N
have	N
in	N
finding	N
a	N
suitable	N
regular	N
expression	N
stems	N
from	N
the	N
fact	N
that	N
a	N
suitable	N
regular	N
expression	N
doesn't	N
exist	N
.	N
You	N
will	N
never	N
arrive	N
at	N
code	N
that	N
is	N
obviously	N
correct	N
,	N
this	N
way	N
.	N
It	N
is	N
much	N
easier	N
to	N
write	N
a	N
simple	N
parser	N
along	N
the	N
lines	N
of	N
above	N
rules	N
.	N
Since	N
the	N
text	N
contained	N
by	N
your	N
string	N
literals	N
is	N
regular	N
,	N
you	N
can	N
use	N
a	N
simple	N
regular	N
expression	N
to	N
look	N
for	N
your	N
keyword	N
---	N
after	N
you	N
extracted	N
that	N
text	N
from	N
its	N
surroundings	N
.	N

Interesting	N
observation	N
.	N
Do	N
you	N
happen	N
to	N
have	N
a	N
test	N
case	N
that	N
will	N
break	N
Tim's	N
solution	N
?	N
It	N
seems	N
to	N
be	N
holding	N
up	N
to	N
all	N
of	N
my	N
test	N
cases	N
.	N

