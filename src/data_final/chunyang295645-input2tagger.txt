How	N
to	N
register	N
a	N
JavaScript	N
callback	N
in	N
a	N
Java	N
Applet	N
?	N

I'm	N
developing	N
an	N
invisible	N
Java	N
Applet	N
,	N
that	N
will	N
be	N
controlled	N
entirely	N
from	N
JavaScript	N
.	N
I	N
can	N
call	N
the	N
applet's	N
Java	N
methods	N
easily	N
,	N
and	N
I	N
can	N
call	N
JavaScript	N
methods	N
from	N
within	N
the	N
applet	N
by	N
using	N
netscape.javascript.JSObject.getWindow	N
(	N
this	N
)	N
.	N
call()	N
.	N
But	N
in	N
order	N
to	N
register	N
a	N
JavaScript	N
callback	N
in	N
the	N
applet	N
,	N
I	N
guess	N
I	N
would	N
need	N
an	N
JavaScript	N
function	N
object	N
of	N
some	N
sort	N
.	N
I	N
would	N
like	N
to	N
do	N
:	N
Which	N
I	N
could	N
call	N
from	N
Javascript	N
:	N
So	N
I	N
could	N
call	N
this	N
function	N
in	N
later	N
code	N
:	N
Does	N
something	N
like	N
this	N
exist	N
?	N
How	N
can	N
I	N
do	N
this	N
?	N
Rigth	N
now	N
I'm	N
thinking	N
of	N
creating	N
some	N
Javascript	N
to	N
handle	N
this	N
callback	N
mechanism	N
instead	N
of	N
doing	N
so	N
from	N
the	N
applet	N
.	N

I	N
am	N
brand	N
new	N
to	N
Java	N
->	N
JavaScript	N
communication	N
,	N
as	N
I	N
planned	N
to	N
explore	N
it	N
this	N
week	N
.	N
A	N
good	N
opportunity	N
here	N
...	N
:-)	N
After	N
some	N
tests	N
,	N
it	N
seems	N
you	N
cannot	N
pass	N
a	N
JS	N
function	N
to	N
a	N
Java	N
applet	N
.	N
Unless	N
I	N
am	N
doing	N
it	N
the	N
wrong	N
way	N
...	N
I	N
tried	N
:	N
where	N
Call	N
is	N
(	N
are	N
)	N
defined	N
as	N
:	N
When	N
I	N
pass	N
a	N
JS	N
function	N
(	N
all	N
tests	N
in	N
FF3	N
)	N
,	N
I	N
get	N
a	N
null	N
on	N
the	N
Java	N
side	N
.	N
Note	N
that	N
the	N
following	N
Java	N
routine	N
allows	N
to	N
display	N
the	N
JS	N
code	N
of	N
DumberTest	N
function	N
!	N
To	N
the	N
point	N
:	N
I	N
made	N
a	N
JS	N
function	N
:	N
I	N
extract	N
the	N
name	N
of	N
the	N
JS	N
function	N
from	N
the	N
toString	N
result	N
and	N
pass	N
it	N
to	N
Java	N
applet	N
.	N
I	N
don't	N
think	N
we	N
can	N
handle	N
anonymous	N
functions	N
because	N
Java	N
call	N
JS	N
functions	N
by	N
name	N
.	N
Java	N
side	N
:	N

It	N
seems	N
that	N
you	N
can	N
only	N
pass	N
functions	N
to	N
Java	N
by	N
name	N
,	N
therefore	N
what	N
you'd	N
need	N
to	N
do	N
is	N
create	N
a	N
fa	N
ade	N
object	N
which	N
would	N
wrap	N
the	N
applet	N
and	N
which	N
would	N
take	N
function	N
references	N
and	N
come	N
up	N
with	N
temporary	N
names	N
for	N
them	N
.	N

win.eval()	N
will	N
call	N
a	N
predefined	N
javascript	N
.	N

eval	N
is	N
more	N
generic	N
,	N
hence	N
less	N
efficient	N
than	N
call	N
for	N
this	N
precise	N
task	N
,	N
and	N
it	N
is	N
more	N
complex	N
to	N
pass	N
parameters	N
to	N
the	N
JS	N
function	N
.	N

I	N
realise	N
this	N
is	N
a	N
really	N
old	N
question	N
,	N
but	N
it	N
ranked	N
2nd	N
in	N
one	N
of	N
my	N
searches	N
for	N
something	N
else	N
,	N
and	N
I	N
think	N
the	N
below	N
may	N
help	N
someone	N
else	N
that	N
finds	N
this	N
.	N
I've	N
recently	N
done	N
something	N
similar	N
whereby	N
a	N
Java	N
applet	N
needs	N
to	N
call	N
back	N
into	N
JavaScript	N
on	N
completion	N
of	N
a	N
task	N
,	N
calling	N
different	N
functions	N
on	N
success	N
or	N
error	N
.	N
As	N
has	N
been	N
the	N
trend	N
over	N
recent	N
times	N
,	N
my	N
needs	N
were	N
to	N
call	N
into	N
anonymous	N
functions	N
defined	N
as	N
parameters	N
being	N
passed	N
to	N
other	N
functions	N
.	N
This	N
is	N
the	N
javascript	N
on	N
the	N
client	N
side	N
:	N
As	N
mentioned	N
in	N
the	N
other	N
answers	N
,	N
Java	N
can	N
only	N
call	N
into	N
JavaScript	N
methods	N
by	N
name	N
.	N
This	N
means	N
you	N
need	N
a	N
global	N
callback	N
method	N
,	N
which	N
can	N
then	N
call	N
into	N
other	N
methods	N
as	N
need	N
be	N
:	N
This	N
function	N
is	N
called	N
directly	N
from	N
within	N
the	N
Java	N
applet	N
:	N
You	N
could	N
hold	N
on	N
to	N
the	N
reference	N
of	N
the	N
parameter	N
object	N
being	N
passed	N
in	N
indefinitely	N
if	N
you	N
wanted	N
to	N
use	N
it	N
as	N
some	N
form	N
of	N
registered	N
callback	N
rather	N
than	N
a	N
throwaway	N
one	N
if	N
need	N
be	N
etc	N
.	N
In	N
our	N
case	N
the	N
processing	N
can	N
be	N
time	N
intenstive	N
,	N
so	N
we	N
actually	N
spin	N
up	N
another	N
thread	N
-	N
the	N
callbacks	N
still	N
work	N
here	N
also	N
:	N

