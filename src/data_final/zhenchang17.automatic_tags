713276	Detecting EOF / TCP teardown using Java sockets from Javascript	^ ^ , ^ ^ V ^ N P ^
713276	I'm creating a Java socket in Javascript , sending an HTTP request and receiving a response correctly but I seem to be unable to detect an EOF or the server closing the socket at the end . What am I doing wrong ? The problem is we never exit the outermost while loop - the server stops transmitting and ( presumably ) closes its end of the connection , yet receiver.read() never returns -1 and all the socket methods return state consistent with the socket still being connected .	L V D ^ N P ^ , V D N N & V D N R & O V P V A P V D ^ & D N V D N P D N , O V O V A , D N V O R V D N P N , D N N V & , R , V D N P D N , R R R V $ & X D N N N N A P D N R V V ,
713276	Wouldn't the this : while ( receiver.available() & & ! eof ) be better ? in lieu of the first while ( receiver.available() ) ?	V D D , P E E & & , ! , V R , P O P D A P E E E ,
713276	Seems a bit redundant - available() is defined as returning the number of bytes of data available to read without blocking , so would return 0 after EOF . Tried it anyway just in case ; doesn't fix the problem .	V D N A , O V V P V D N P V P ^ A P V P V , P V V $ P ^ , V O R R P N , V V D N ,
713276	Or do you mean in place of the outermost while ? Data being available to read without blocking is independent of whether the server has closed the socket - there could be pauses in transmission , and the OS could have buffered input data . So we must test both separately .	& V O V P N P D N N , O V A P V P V V A P P D N V V D N , X V V V P N , & D ^ V V V N N , P O V N D R ,
713276	No , I meant the inner while , but your first comment is right : I'm wrong .	! , O V D A N , & D A N V R , L A ,
713276	Ok . What's the value of eof when the code reaches this comment ? // at this point response does contain the expected HTTP response What's the symptom ? I assume it's an infinite loop ?	! , L D N P O R D N V D N , L P D N N V V D V D N L D N , O V L D A N ,
713276	eof is still 0 at that point ( otherwise we'd exit the outermost while() correctly and I'd not be posting this ) . Question edited - hopefully the problem is clearer now ?	O V R $ P D N , R L V D N ^ R & L R V V D , , N V , R D N V R R ,
713276	OK , further research suggests there is no non-blocking way to discover whether the remote side has closed a socket . However , it is possible to achieve this using NIO channels :	A , A N V R V D A N P V P D A N V V D N , R , O V R P V D V ^ N ,
713276	When the end of the stream is reached , available() returns 0 , so in your code , you never read the -1	R D N P D N V V , ^ V $ , R P D N , O R V D $
713276	Right . But read() will block until either EOF is reached or there is more data , and Javascript is single-threaded so we don't want to issue a read without knowing for certain we have data to read . And available() can return 0 during transmission , so we can't use that to test for EOF .	! , & O V N P D N V V & R V A N , & N V V P O V V P N N V P V P A O V N P V , & O V V $ P N , P O V V O P N P ^ ,
