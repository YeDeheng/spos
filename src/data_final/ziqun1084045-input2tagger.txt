Should	N
web	N
developers	N
still	N
learn	N
JavaScript	N
?	N

Now	N
that	N
frameworks	N
like	N
GWT	N
,	N
Morfik	N
etc	N
exist	N
which	N
compile	N
Java	N
client	N
side	N
code	N
into	N
major	N
JavaScript	N
dialects	N
,	N
is	N
it	N
still	N
worth	N
learning	N
JavaScript	N
?	N

In	N
my	N
book	N
,	N
yes	N
.	N
I'm	N
a	N
strong	N
believer	N
in	N
understanding	N
the	N
underlying	N
technology	N
beneath	N
whatever	N
toolkits	N
you're	N
using	N
.	N
Abstractions	N
are	N
leaky	N
-	N
you'll	N
run	N
into	N
trouble	N
down	N
the	N
line	N
if	N
you	N
try	N
to	N
get	N
away	N
with	N
only	N
understanding	N
a	N
high-level	N
toolkit	N
,	N
and	N
not	N
the	N
underlying	N
technology	N
.	N
Sooner	N
or	N
later	N
you'll	N
need	N
to	N
debug	N
your	N
project	N
at	N
the	N
JavaScript	N
(	N
or	N
whatever	N
)	N
level	N
.	N

Not	N
really	N
worth	N
it's	N
own	N
answer	N
,	N
so	N
put	N
here	N
.	N
If	N
you	N
use	N
one	N
of	N
the	N
Java	N
->	N
Javascript	N
converters	N
,	N
you	N
lose	N
a	N
lot	N
of	N
javascript	N
features	N
such	N
as	N
dynamic	N
typing	N
,	N
and	N
the	N
ability	N
to	N
use	N
functions	N
as	N
proper	N
objects	N
.	N
I	N
don't	N
really	N
see	N
why	N
people	N
look	N
at	N
javascript	N
as	N
a	N
low	N
level	N
language	N
.	N
Combined	N
with	N
frameworks	N
(	N
written	N
in	N
javascript	N
)	N
such	N
as	N
jQuery	N
,	N
it's	N
a	N
easy	N
to	N
use	N
and	N
powerful	N
language	N
.	N

@Macha	N
:	N
Well	N
said	N
.	N
JS	N
in	N
it's	N
own	N
right	N
is	N
extremely	N
powerful	N
(	N
and	N
very	N
different	N
from	N
Java	N
)	N
.	N
Why	N
cover	N
it	N
up	N
with	N
abstractions	N
?	N

Agreed	N
.	N
Using	N
stuff	N
like	N
Gwt	N
without	N
knowing	N
JS	N
is	N
like	N
using	N
some	N
database	N
tool	N
without	N
knowing	N
SQL	N
.	N
While	N
that	N
may	N
work	N
,	N
you're	N
going	N
to	N
get	N
better	N
results	N
if	N
you	N
actually	N
know	N
what's	N
going	N
on	N
.	N

Understanding	N
the	N
technology	N
behind	N
your	N
framework	N
reduces	N
the	N
time	N
spending	N
on	N
debugging	N
the	N
things	N
you	N
do	N
with	N
your	N
framework	N
.	N
so	N
in	N
my	N
opinion	N
it's	N
always	N
good	N
to	N
know	N
whats	N
going	N
on	N
behind	N
the	N
scene	N
.	N

Stretching	N
this	N
further	N
...	N
Should	N
you	N
learn	N
assembly	N
language	N
nowaday	N
with	N
so	N
many	N
higher	N
level	N
languages	N
?	N
Should	N
you	N
learn	N
how	N
to	N
do	N
basic	N
arithmetic	N
like	N
subtraction	N
and	N
addition	N
by	N
hand	N
when	N
now	N
we	N
have	N
calculator	N
and	N
computer	N
that	N
can	N
do	N
this	N
for	N
you	N
?	N
Well	N
,	N
I'd	N
say	N
maybe	N
you	N
won't	N
need	N
to	N
if	N
you	N
don't	N
have	N
any	N
reason	N
to	N
go	N
deep	N
down	N
,	N
but	N
someone	N
will	N
have	N
to	N
still	N
.	N
As	N
with	N
all	N
things	N
,	N
there	N
is	N
a	N
balance	N
.	N
Know	N
that	N
it	N
will	N
be	N
to	N
your	N
disadvantage	N
if	N
you	N
don't	N
know	N
the	N
lower	N
level	N
stuffs	N
,	N
but	N
sometimes	N
it	N
is	N
necessary	N
to	N
skip	N
it	N
so	N
you	N
can	N
be	N
deep	N
in	N
something	N
else	N
.	N
You	N
have	N
to	N
admit	N
there	N
are	N
so	N
much	N
technology	N
out	N
there	N
that	N
you	N
won't	N
be	N
able	N
to	N
be	N
an	N
expert	N
in	N
all	N
things	N
.	N
In	N
that	N
case	N
,	N
knowing	N
someone	N
else	N
who	N
does	N
is	N
a	N
good	N
thing	N
.	N
So	N
pick	N
your	N
choice	N
and	N
go	N
with	N
what	N
interest	N
you	N
.	N
If	N
you	N
think	N
you	N
are	N
interested	N
in	N
learning	N
JavaScript	N
go	N
for	N
it	N
.	N
If	N
not	N
,	N
you	N
can	N
stick	N
to	N
your	N
level	N
of	N
abstraction	N
and	N
get	N
a	N
JavaScript	N
buddy	N
that	N
can	N
help	N
you	N
when	N
you	N
are	N
stuck	N
.	N

Yes	N
,	N
...	N
and	N
I	N
speak	N
with	N
experience	N
:	N
I've	N
never	N
learned	N
javascript	N
and	N
only	N
used	N
parts	N
of	N
it	N
,	N
when	N
I	N
encountered	N
it	N
in	N
google	N
searches	N
for	N
questions	N
.	N
Now	N
that	N
I'm	N
building	N
a	N
Web	N
application	N
,	N
I	N
notice	N
that	N
not	N
all	N
abstractions	N
away	N
from	N
javascript	N
have	N
the	N
desired	N
functionality	N
,	N
and	N
I	N
need	N
to	N
go	N
into	N
javascript	N
to	N
solve	N
it	N
.	N
I	N
notice	N
that	N
I	N
miss	N
the	N
fundamental	N
knowledge	N
I	N
have	N
with	N
other	N
languages	N
,	N
just	N
like	N
I	N
miss	N
the	N
'	N
javascript	N
programming	N
language	N
'	N
book	N
(	N
I'm	N
not	N
sure	N
it	N
exists	N
but	N
I	N
have	N
similar	N
copies	N
for	N
C	N
,	N
C++	N
and	N
Java	N
)	N
.	N
So	N
today	N
I	N
ordered	N
Javascript	N
:	N
The	N
good	N
parts	N
and	N
I	N
will	N
learn	N
it	N
...	N

Crockford's	N
The	N
Good	N
Parts	N
is	N
not	N
really	N
a	N
beginner's	N
book	N
.	N
I	N
suggest	N
you	N
first	N
start	N
with	N
Flanagan's	N
Javascript	N
The	N
Definitive	N
guide	N
,	N
and	N
then	N
move	N
on	N
to	N
The	N
Good	N
Parts	N
.	N
http://www.amazon.com/JavaScript-Definitive-Guide-David-Flanagan/dp/0596101996/ref=sr_1_1?ie=UTF8	N
=b	N
ooks	N
=1246804047	N
=8-1	N

I	N
would	N
suggest	N
cross-referencing	N
the	N
two	N
;	N
for	N
the	N
language	N
features	N
that	N
Crockford	N
leaves	N
out	N
of	N
The	N
Good	N
Parts	N
,	N
I	N
wouldn't	N
spend	N
too	N
much	N
time	N
studying	N
them	N
while	N
reading	N
The	N
Definitive	N
Guide	N
.	N
You	N
may	N
eventually	N
need	N
to	N
understand	N
those	N
features	N
,	N
but	N
part	N
of	N
Crockford's	N
point	N
is	N
that	N
a	N
bunch	N
of	N
things	N
in	N
the	N
Javascript	N
language	N
were	N
poorly	N
designed	N
and	N
really	N
shouldn't	N
be	N
there	N
.	N
I've	N
found	N
that	N
,	N
for	N
the	N
most	N
part	N
,	N
I've	N
agreed	N
with	N
him	N
.	N
(	N
I	N
also	N
learned	N
a	N
fair	N
amount	N
from	N
him	N
.	N
)	N

Dreas	N
:	N
Thanks	N
for	N
the	N
tip	N
,	N
I	N
will	N
get	N
the	N
book	N
soon	N
so	N
I	N
will	N
see	N
if	N
I	N
still	N
miss	N
some	N
fundamentals	N
.	N
Note	N
that	N
I've	N
learned	N
already	N
a	N
lot	N
of	N
different	N
languages	N
,	N
so	N
I	N
will	N
probably	N
understand	N
more	N
of	N
it	N
that	N
a	N
full	N
beginner	N
.	N

I	N
think	N
the	N
reality	N
of	N
browser	N
bugs	N
will	N
make	N
being	N
able	N
to	N
diagnose	N
and	N
understand	N
the	N
generated	N
JavaScript	N
necessary	N
for	N
a	N
long	N
time	N
.	N
I	N
worked	N
with	N
a	N
Spreadsheet	N
company	N
for	N
OS	N
/	N
2	N
,	N
and	N
they	N
had	N
to	N
read	N
the	N
generated	N
assembler	N
from	N
the	N
C++	N
code	N
because	N
the	N
IBM	N
compiler	N
would	N
generate	N
buggy	N
machine	N
code	N
at	N
times	N
.	N
So	N
while	N
they	N
may	N
not	N
have	N
known	N
enough	N
Assembler	N
to	N
write	N
a	N
whole	N
project	N
in	N
it	N
,	N
they	N
certainly	N
had	N
to	N
know	N
enough	N
to	N
track	N
down	N
problems	N
.	N
That	N
being	N
said	N
,	N
there	N
are	N
also	N
many	N
web	N
frameworks	N
that	N
require	N
you	N
to	N
code	N
your	N
own	N
javascript	N
,	N
and	N
a	N
given	N
toolkit	N
won't	N
necessarily	N
do	N
everything	N
that	N
you	N
need	N
to	N
do	N
without	N
directly	N
writing	N
some	N
javascript	N
.	N
You	N
can	N
choose	N
frameworks	N
that	N
avoid	N
it	N
if	N
you	N
prefer	N
,	N
but	N
it	N
isn't	N
at	N
all	N
obvious	N
that	N
,	N
unlike	N
say	N
Assembler	N
for	N
application	N
development	N
,	N
the	N
Web	N
development	N
community	N
has	N
decided	N
to	N
abstract	N
away	N
any	N
involvement	N
with	N
it	N
.	N
You	N
may	N
well	N
end	N
up	N
on	N
projects	N
that	N
need	N
it	N
.	N

ABSOLUTELY	N
.	N
In	N
my	N
opinion	N
,	N
abstraction	N
is	N
important	N
,	N
but	N
knowing	N
how	N
that	N
abstraction	N
works	N
is	N
equally	N
as	N
important	N
.	N
I've	N
seen	N
developers	N
who	N
live	N
and	N
die	N
by	N
their	N
frameworks	N
(	N
javascript	N
:	N
jquery	N
,	N
yui	N
,	N
etc	N
...	N
or	N
php	N
:	N
zend	N
,	N
cake	N
,	N
etc	N
...	N
)	N
,	N
but	N
have	N
no	N
clue	N
how	N
to	N
do	N
anything	N
productive	N
without	N
them	N
.	N
Who	N
would	N
you	N
rather	N
be	N
(	N
or	N
hire	N
)	N
?	N
The	N
guy	N
who	N
knows	N
how	N
everything	N
works	N
,	N
but	N
improves	N
his	N
productivity	N
by	N
using	N
frameworks	N
and	N
libraries	N
...	N
or	N
the	N
guy	N
who	N
uses	N
these	N
resources	N
with	N
no	N
idea	N
how	N
they	N
actually	N
work	N
?	N

Actually	N
,	N
drawing	N
a	N
parallel	N
to	N
assembly	N
language	N
is	N
a	N
bit	N
missing	N
the	N
point	N
.	N
Assembly	N
was	N
platform	N
specific	N
and	N
the	N
move	N
to	N
C	N
enabled	N
a	N
certain	N
level	N
of	N
platform	N
agnosticism	N
,	N
allowing	N
the	N
developer	N
to	N
be	N
more	N
productive	N
on	N
multiple	N
platforms	N
.	N
Hence	N
,	N
there	N
was	N
a	N
real	N
productivity	N
effect	N
.	N
Learning	N
all	N
your	N
rich	N
web	N
chops	N
on	N
something	N
like	N
GWT	N
is	N
more	N
limiting	N
.	N
It	N
is	N
,	N
after	N
all	N
,	N
based	N
on	N
Java	N
,	N
and	N
the	N
web	N
is	N
way	N
larger	N
in	N
scope	N
than	N
just	N
Java	N
.	N
You'd	N
be	N
seriously	N
limiting	N
yourself	N
if	N
all	N
you	N
know	N
is	N
GWT	N
but	N
not	N
the	N
inner	N
workings	N
of	N
the	N
generated	N
Javascript	N
(	N
Can't	N
comment	N
on	N
Morfik	N
as	N
I	N
don't	N
know	N
it	N
)	N
.	N
However	N
,	N
employing	N
something	N
like	N
JQuery	N
in	N
order	N
to	N
be	N
more	N
productive	N
when	N
coding	N
Javascript	N
is	N
much	N
better	N
.	N
JQuery	N
can	N
be	N
used	N
on	N
any	N
browser	N
running	N
on	N
any	N
OS	N
,	N
so	N
it	N
doesn't	N
limit	N
you	N
.	N

I'd	N
say	N
yes	N
.	N
I've	N
met	N
people	N
who	N
claimed	N
to	N
know	N
javascript	N
,	N
when	N
all	N
they	N
could	N
do	N
is	N
do	N
a	N
couple	N
of	N
jquery	N
function	N
calls	N
.	N
Javascript	N
(	N
ECMAscript	N
)	N
is	N
a	N
beatiful	N
little	N
(	N
ok	N
,	N
not	N
so	N
little	N
)	N
language	N
.	N
Abstracting	N
a	N
bit	N
from	N
javascript	N
-	N
define	N
"	N
worth	N
learning	N
"	N
.	N
This	N
kind	N
of	N
thinking	N
was	N
always	N
a	N
conundrum	N
to	N
me	N
.	N
Are	N
you	N
,	N
per	N
chance	N
,	N
afraid	N
of	N
learning	N
something	N
new	N
?	N
I	N
guess	N
,	N
this	N
kind	N
of	N
thinking	N
is	N
what	N
really	N
separates	N
a	N
coder	N
from	N
a	N
programmer	N
.	N

A	N
web	N
developer	N
who	N
does	N
not	N
know	N
Javascript	N
is	N
like	N
an	N
auto	N
mechanic	N
who	N
does	N
not	N
know	N
how	N
to	N
change	N
a	N
tire	N
.	N

JavaScript	N
is	N
the	N
core	N
of	N
interactive	N
client-side	N
development	N
.	N
It	N
is	N
absolutely	N
essential	N
.	N
After	N
you	N
know	N
JavaScript	N
you	N
might	N
decide	N
to	N
try	N
out	N
other	N
things	N
that	N
compile	N
to	N
JavaScript	N
if	N
you	N
find	N
them	N
easier	N
.	N
Also	N
if	N
you	N
want	N
to	N
work	N
professional	N
in	N
web	N
development	N
for	N
some	N
company	N
then	N
you	N
are	N
going	N
to	N
have	N
to	N
know	N
JavaScript	N
.	N
Besides	N
,	N
JavaScript	N
is	N
getting	N
more	N
and	N
more	N
popular	N
as	N
the	N
execution	N
of	N
the	N
language	N
in	N
the	N
browser	N
gets	N
faster	N
and	N
as	N
it	N
becomes	N
more	N
popular	N
in	N
Server-side	N
development	N
as	N
well	N
.	N

