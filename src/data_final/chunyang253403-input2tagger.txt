How	N
to	N
prevent	N
a	N
user	N
from	N
seeing	N
previous	N
users	N
'	N
info	N
by	N
hitting	N
the	N
"	N
Back	N
"	N
button	N

I	N
am	N
developing	N
a	N
java	N
web	N
app	N
using	N
servlet	N
,	N
in	N
order	N
to	N
prevent	N
user	N
from	N
hitting	N
the	N
back	N
button	N
to	N
see	N
previous	N
users	N
'	N
info	N
,	N
I	N
have	N
the	N
following	N
code	N
:	N
Besides	N
I	N
also	N
have	N
the	N
following	N
code	N
in	N
the	N
file	N
:	N
web	N
/	N
WEB-INF	N
/	N
web.xml	N
And	N
the	N
ResponseHeaderFilter.java	N
looks	N
like	N
this	N
:	N
So	N
far	N
it's	N
still	N
not	N
working	N
correctly	N
.	N
The	N
back	N
button	N
will	N
bring	N
up	N
a	N
warning	N
window	N
saying	N
the	N
data	N
has	N
expired	N
,	N
it	N
asks	N
if	N
the	N
user	N
wants	N
to	N
repost	N
it	N
.	N
If	N
you	N
choose	N
yes	N
,	N
it	N
will	N
still	N
display	N
the	N
previous	N
pages	N
info	N
.	N
What	N
am	N
I	N
doing	N
wrong	N
?	N
What's	N
the	N
fix	N
?	N
Frank	N
Yes	N
,	N
I	N
am	N
developing	N
a	N
web	N
app	N
for	N
a	N
PC	N
in	N
public	N
place	N
,	N
if	N
user	N
B	N
hits	N
the	N
back	N
button	N
he	N
might	N
see	N
user	N
A's	N
private	N
info	N
.	N
I	N
was	N
trying	N
to	N
use	N
session	N
id	N
with	N
servlet	N
,	N
but	N
how	N
to	N
do	N
it	N
,	N
any	N
sample	N
code	N
?	N
I	N
also	N
tried	N
the	N
following	N
:	N
It	N
works	N
for	N
IE	N
but	N
but	N
Firefox	N
.	N

Breaking	N
the	N
back	N
button	N
is	N
a	N
cardinal	N
sin	N
of	N
web	N
development	N
.	N
but	N
you	N
could	N
try	N
a	N
bit	N
of	N
java	N
script	N
in	N
the	N
onload	N
that	N
refreshed	N
the	N
details	N
according	N
to	N
the	N
currently	N
logged	N
in	N
session	N
.	N

Breaking	N
the	N
back	N
button	N
is	N
only	N
relevant	N
within	N
a	N
single	N
session	N
.	N
For	N
example	N
,	N
I	N
can't	N
open	N
a	N
new	N
browser	N
window	N
and	N
hit	N
the	N
"	N
back	N
"	N
button	N
to	N
go	N
to	N
the	N
last	N
website	N
I	N
visited	N
.	N

I'm	N
not	N
sure	N
if	N
I	N
understand	N
your	N
problem	N
exactly	N
.	N
Are	N
you	N
concerned	N
about	N
Person	N
A	N
logging	N
off	N
,	N
Person	N
B	N
logs	N
in	N
from	N
the	N
same	N
PC	N
and	N
browser	N
instance	N
,	N
and	N
then	N
you	N
want	N
to	N
prevent	N
Person	N
B	N
from	N
seeing	N
whatever	N
A	N
was	N
viewing	N
?	N
If	N
so	N
,	N
it	N
should	N
be	N
sufficient	N
to	N
check	N
the	N
credentials	N
of	N
the	N
user	N
on	N
every	N
page	N
load	N
.	N
Check	N
that	N
the	N
current	N
user	N
is	N
authorized	N
to	N
view	N
the	N
data	N
being	N
requested	N
.	N

How	N
will	N
hitting	N
the	N
back	N
button	N
cause	N
the	N
user	N
to	N
see	N
another	N
user's	N
data	N
?	N
What	N
is	N
your	N
use	N
case	N
?	N
Is	N
it	N
designed	N
for	N
a	N
public	N
terminal	N
,	N
where	N
each	N
user	N
submits	N
data	N
and	N
then	N
leaves	N
?	N
In	N
this	N
case	N
,	N
associate	N
each	N
input	N
with	N
a	N
unique	N
session	N
id	N
.	N
Keep	N
track	N
of	N
valid	N
session	N
ids	N
in	N
your	N
server	N
.	N
Once	N
the	N
input	N
is	N
submitted	N
,	N
remove	N
that	N
session	N
id	N
from	N
the	N
valid	N
ids	N
.	N
If	N
it	N
comes	N
up	N
again	N
,	N
then	N
don't	N
display	N
the	N
information	N
.	N

I	N
agree	N
-	N
it	N
sounds	N
like	N
he's	N
trying	N
to	N
solve	N
a	N
problem	N
that	N
shouldn't	N
exist	N
...	N
running	N
the	N
session	N
as	N
a	N
singleton	N
or	N
something	N
?	N

Your	N
problem	N
is	N
that	N
you're	N
trying	N
to	N
keep	N
the	N
client	N
from	N
seeing	N
what's	N
on	N
his	N
or	N
her	N
own	N
computer	N
.	N
You	N
can't	N
keep	N
them	N
from	N
looking	N
at	N
their	N
browser	N
cache	N
.	N
You	N
can't	N
keep	N
them	N
from	N
disabling	N
JavaScript	N
(	N
and	N
thus	N
your	N
scripting	N
code	N
)	N
.	N
You	N
can't	N
keep	N
them	N
from	N
using	N
a	N
browser	N
that	N
doesn't	N
observe	N
that	N
"	N
repost	N
"	N
convention	N
that	N
you	N
mention	N
.	N
This	N
is	N
not	N
a	N
problem	N
that	N
can	N
be	N
solved	N
with	N
JavaScript	N
or	N
a	N
server-side	N
solution	N
.	N
That	N
part	N
of	N
why	N
"	N
breaking	N
the	N
back	N
button	N
"	N
is	N
frowned	N
upon	N
:	N
it	N
doesn't	N
actually	N
solve	N
anything	N
.	N

Actually	N
,	N
you	N
can	N
turn	N
caching	N
off	N
.	N
Most	N
browsers	N
respect	N
this	N
,	N
but	N
it's	N
not	N
guaranteed	N
.	N

As	N
I	N
mentioned	N
in	N
my	N
post	N
here	N
,	N
you	N
can	N
turn	N
off	N
caching	N
but	N
history	N
may	N
be	N
treated	N
differently	N
by	N
different	N
user	N
agents	N
.	N
The	N
HTTP	N
specification	N
makes	N
a	N
distinction	N
between	N
the	N
two	N
but	N
doesn't	N
really	N
define	N
the	N
concept	N
of	N
history	N
as	N
well	N
as	N
it	N
defines	N
caching	N
.	N

I	N
had	N
a	N
similar	N
problem	N
in	N
.	N
Net	N
.	N
I	N
added	N
the	N
following	N
javascript	N
to	N
my	N
logout	N
page	N
:	N
document.execCommand	N
(	N
"	N
ClearAuthenticationCache	N
"	N
,	N
"	N
false	N
")	N
;	N
now	N
if	N
you	N
press	N
the	N
back	N
button	N
you	N
need	N
to	N
authenticate	N
again	N
.	N

Have	N
you	N
considered	N
that	N
a	N
malicious	N
user	N
could	N
simply	N
turn	N
off	N
Javascript	N
?	N

It	N
sounds	N
like	N
your	N
real	N
problem	N
is	N
that	N
the	N
re-post	N
works	N
.	N
That	N
would	N
probably	N
be	N
because	N
you	N
:	N
are	N
trusting	N
credentials	N
from	N
the	N
browser	N
rather	N
than	N
the	N
current	N
session	N
,	N
or	N
are	N
not	N
checking	N
that	N
the	N
current	N
session	N
is	N
allowed	N
access	N
the	N
data	N
represented	N
by	N
a	N
key	N
/	N
identifier	N
value	N
sent	N
from	N
the	N
browser	N
I	N
recommend	N
that	N
after	N
a	N
user	N
has	N
logged	N
in	N
you	N
never	N
trust	N
a	N
user	N
name	N
submitted	N
by	N
the	N
browser	N
.	N
Ideally	N
use	N
the	N
security	N
services	N
of	N
a	N
framework	N
like	N
Spring	N
Security	N
but	N
in	N
their	N
absence	N
you	N
can	N
rely	N
on	N
HttpServletRequest.getUserPrincipal()	N
.	N
To	N
make	N
sure	N
the	N
current	N
session	N
is	N
allowed	N
access	N
the	N
data	N
you	N
could	N
use	N
an	N
Access	N
Control	N
List	N
mechanism	N
provided	N
by	N
a	N
framework	N
such	N
as	N
Spring	N
Security	N
or	N
include	N
a	N
WHERE	N
OWNER=	N
?	N
clause	N
in	N
your	N
database	N
queries	N
.	N

If	N
you're	N
worried	N
about	N
someone	N
seeing	N
what	N
was	N
in	N
a	N
form	N
in	N
a	N
previous	N
page	N
you	N
could	N
use	N
a	N
hidden	N
form	N
for	N
the	N
"	N
real	N
"	N
post	N
and	N
use	N
one	N
that's	N
just	N
for	N
display	N
for	N
the	N
user	N
.	N
When	N
the	N
user	N
submits	N
the	N
display	N
form	N
,	N
you	N
copy	N
all	N
of	N
the	N
fields	N
to	N
the	N
hidden	N
form	N
,	N
clear	N
the	N
display	N
form	N
,	N
then	N
submit	N
the	N
hidden	N
one	N
.	N
I	N
agree	N
with	N
everyone	N
else	N
-	N
fiddling	N
with	N
the	N
back	N
button	N
this	N
is	N
a	N
bad	N
way	N
to	N
handle	N
protecting	N
information	N
.	N

I'm	N
not	N
100%	N
sure	N
this	N
is	N
a	N
fix	N
to	N
your	N
issue	N
,	N
as	N
I	N
don't	N
fully	N
understand	N
how	N
you	N
would	N
get	N
another	N
user's	N
data	N
using	N
back	N
.	N
However	N
,	N
I	N
know	N
that	N
for	N
the	N
web	N
apps	N
I	N
develop	N
I	N
try	N
to	N
exclusively	N
use	N
Redirect	N
After	N
Post	N
to	N
avoid	N
back	N
button	N
and	N
refresh	N
duplicate	N
form	N
submissions	N
.	N

Jeff	N
Atwood	N
described	N
a	N
way	N
to	N
prevent	N
CSRF	N
and	N
XSRF	N
attacks	N
here	N
.	N
You	N
could	N
use	N
this	N
technique	N
to	N
solve	N
your	N
"	N
users	N
seeing	N
what	N
they	N
should	N
not	N
see	N
"	N
problem	N
.	N

I'm	N
not	N
sure	N
I	N
understand	N
your	N
problem	N
correctly	N
,	N
but	N
it	N
sounds	N
like	N
you	N
are	N
allowing	N
rePOSTs	N
.	N
One	N
approach	N
to	N
prevent	N
resubmission	N
is	N
to	N
use	N
tokens	N
.	N
Put	N
a	N
random	N
token	N
in	N
the	N
form	N
and	N
session	N
.	N
On	N
submission	N
check	N
that	N
the	N
submitted	N
token	N
matches	N
the	N
token	N
in	N
the	N
session	N
if	N
it	N
does	N
,	N
replace	N
the	N
token	N
in	N
the	N
session	N
with	N
a	N
fresh	N
one	N
and	N
process	N
the	N
request	N
otherwise	N
stop	N
processing	N
the	N
request	N
)	N
.	N

All	N
of	N
the	N
different	N
browsers	N
have	N
different	N
behaviors	N
and	N
quirks	N
when	N
it	N
comes	N
to	N
how	N
history	N
relates	N
to	N
the	N
cache	N
and	N
the	N
various	N
headers	N
available	N
to	N
control	N
it	N
.	N
Firefox	N
3	N
works	N
differently	N
from	N
Firefox	N
2	N
,	N
re-displaying	N
potentially	N
sensitive	N
data	N
when	N
a	N
user	N
clicks	N
the	N
back	N
button	N
in	N
spite	N
of	N
using	N
caching	N
directives	N
to	N
prevent	N
it	N
.	N
The	N
best	N
solution	N
is	N
to	N
use	N
a	N
session	N
cookie	N
that	N
is	N
not	N
persisted	N
and	N
inform	N
the	N
user	N
of	N
the	N
need	N
to	N
close	N
the	N
browser	N
window	N
after	N
logging	N
out	N
.	N
Especially	N
if	N
they	N
are	N
at	N
a	N
public	N
terminal	N
.	N
Painful	N
,	N
I	N
know	N
,	N
but	N
current	N
browser	N
offerings	N
and	N
the	N
HTTP	N
specification	N
do	N
not	N
provide	N
any	N
mechanisms	N
for	N
dealing	N
with	N
browser	N
history	N
.	N
History	N
may	N
be	N
treated	N
differently	N
than	N
caching	N
by	N
a	N
user	N
agent	N
according	N
to	N
the	N
HTTP	N
specification	N
.	N
See	N
13.13	N
History	N
Lists	N
as	N
defined	N
in	N
RFC	N
2616	N
Hypertext	N
Transfer	N
Protocol	N
--	N
HTTP	N
/	N
1.1	N
for	N
the	N
problem	N
and	N
rationale	N
.	N

I	N
think	N
this	N
is	N
as	N
much	N
a	N
user	N
interface	N
challenge	N
as	N
a	N
coding	N
problem	N
.	N
On	N
top	N
of	N
whatever	N
anti-caching	N
techniques	N
you	N
employ	N
,	N
you	N
need	N
to	N
make	N
it	N
clear	N
to	N
the	N
user	N
that	N
they	N
must	N
hit	N
a	N
big	N
,	N
obvious	N
"	N
Logout	N
"	N
button	N
(	N
or	N
equivalent	N
)	N
when	N
they	N
are	N
done	N
.	N

if	N
this	N
might	N
help	N
.	N
This	N
works	N
for	N
ASP	N
,	N
use	N
an	N
equivalent	N
solution	N
for	N
other	N
languages	N
.	N
%	N
response.buffer	N
=	N
true%	N
>	N
%	N
Response.CacheControl	N
=	N
"	N
no-cache	N
"	N
%	N
>	N
%	N
Response.AddHeader	N
"	N
Pragma	N
"	N
,	N
"	N
no-cache	N
"	N
%	N
>	N
%	N
Response.Expires	N
=	N
-1	N
%	N
>	N

