How	N
would	N
I	N
write	N
a	N
Java	N
regex	N
that	N
gets	N
the	N
contents	N
of	N
a	N

I'm	N
trying	N
to	N
integrate	N
analytics	N
into	N
my	N
GWT	N
application	N
.	N
To	N
do	N
this	N
,	N
I'm	N
calling	N
a	N
service	N
that	N
returns	N
a	N
String	N
of	N
HTML	N
that	N
needs	N
to	N
be	N
parsed	N
and	N
eval'ed	N
.	N
I	N
need	N
a	N
regex	N
that	N
looks	N
for	N
and	N
grabs	N
either	N
1	N
)	N
the	N
body	N
of	N
the	N
tag	N
or	N
2	N
)	N
the	N
contents	N
of	N
the	N
"	N
src	N
"	N
attribute	N
.	N
I	N
want	N
to	N
eval	N
both	N
of	N
these	N
with	N
JavaScript	N
.	N
I'm	N
happy	N
with	N
assuming	N
that	N
if	N
a	N
"	N
src	N
"	N
attribute	N
exists	N
,	N
the	N
body	N
can	N
be	N
ignored	N
.	N
Thanks	N
,	N
Matt	N

This	N
question	N
is	N
really	N
confusing	N
,	N
Java	N
!	N
=	N
JavaScript	N

I	N
need	N
to	N
do	N
the	N
parsing	N
of	N
HTML	N
with	N
Java	N
.	N
After	N
getting	N
the	N
JavaScript	N
,	N
I'll	N
eval	N
it	N
.	N
Oh	N
,	N
and	N
I'm	N
using	N
GWT	N
,	N
so	N
Java	N
/	N
is	N
JavaScript	N
.	N
;-)	N

It	N
seems	N
like	N
there's	N
got	N
to	N
be	N
a	N
better	N
way	N
to	N
do	N
what	N
you're	N
trying	N
to	N
do	N
.	N
What	N
you	N
propose	N
is	N
a	N
very	N
unnatural	N
pairing	N
(	N
regex	N
to	N
find	N
js	N
tag	N
&	N
then	N
eval	N
while	N
using	N
GWT	N
)	N

Someone	N
needs	N
to	N
tag	N
this	N
with	N
'	N
GWT	N
'	N
or	N
'	N
Google	N
Web	N
Toolkit	N
'	N
.	N
Also	N
,	N
please	N
make	N
it	N
more	N
clear	N
in	N
the	N
question	N
that	N
you	N
are	N
using	N
GWT	N
.	N
Otherwise	N
,	N
this	N
question	N
doesn't	N
make	N
much	N
sense	N
(	N
better	N
ways	N
to	N
do	N
the	N
same	N
thing	N
in	N
a	N
js	N
context	N
)	N
.	N

To	N
match	N
the	N
body	N
of	N
the	N
tag	N
,	N
you	N
can	N
try	N
something	N
like	N
which	N
you	N
want	N
to	N
match	N
case-insensitively	N
.	N
Works	N
assuming	N
there	N
is	N
no	N
""	N
appearing	N
in	N
the	N
actual	N
script	N
body	N
and	N
no	N
"	N
>	N
"	N
in	N
the	N
attributes	N
for	N
the	N
tag	N
.	N
You	N
can	N
add	N
whitespace	N
globbers	N
to	N
the	N
regexp	N
to	N
make	N
it	N
more	N
robust	N
.	N
Note	N
the	N
use	N
of	N
.	N
*	N
?	N
to	N
make	N
sure	N
the	N
scanning	N
stops	N
at	N
the	N
first	N
closing	N
tag	N
.	N
To	N
add	N
the	N
src	N
attribute	N
,	N
you	N
can	N
try	N
and	N
use	N
the	N
second	N
submatch	N
to	N
get	N
'	N
src	N
'	N
,	N
and	N
third	N
to	N
get	N
the	N
body	N
.	N
Again	N
,	N
you	N
might	N
want	N
to	N
add	N
whitespace	N
globbers	N
.	N
But	N
would	N
be	N
best	N
off	N
by	N
running	N
the	N
thing	N
through	N
a	N
proper	N
HTML	N
/	N
XML	N
/	N
SGML	N
parser	N
,	N
because	N
regexps	N
can	N
blow	N
up	N
in	N
special	N
cases	N
.	N

You	N
could	N
use	N
something	N
like	N
this	N
:	N
The	N
regex	N
uses	N
the	N
lazy	N
star	N
quantifier	N
and	N
should	N
work	N
in	N
most	N
cases	N
but	N
it	N
could	N
certainly	N
be	N
improved	N
upon	N
.	N
It	N
will	N
match	N
in	N
$1	N
the	N
attributes	N
of	N
the	N
script	N
tag	N
,	N
and	N
in	N
$2	N
the	N
body	N
.	N
You	N
can	N
then	N
check	N
for	N
the	N
src	N
attribute	N
in	N
$1	N
(	N
if	N
it's	N
not	N
empty	N
)	N
.	N

How	N
about	N
to	N
start	N
with	N
.	N
You	N
may	N
need	N
to	N
customize	N
it	N
a	N
bit	N
to	N
accept	N
the	N
src	N
attribute	N
with	N
single	N
quotes	N
or	N
without	N
quotes	N
.	N
ignore	N
white	N
between	N
the	N
'	N
script	N
'	N
and	N
'	N
'	N
You	N
also	N
must	N
use	N
the	N
DOTALL	N
mode	N
to	N
ensure	N
the	N
.	N
captures	N
newlines	N
.	N

Your	N
answer	N
won't	N
handle	N

Agreed	N
.	N
There	N
are	N
many	N
cases	N
it	N
won't	N
handle	N
(	N
like	N
the	N
type	N
attribute	N
of	N
the	N
script	N
tag	N
)	N
.	N
I	N
suggested	N
this	N
as	N
a	N
start	N
to	N
build	N
from	N
.	N

and	N
it	N
will	N
match	N
everything	N
between	N
first	N
and	N
last	N
which	N
wouldn't	N
work	N
nicely	N
when	N
there	N
are	N
multiple	N
scripts	N
on	N
the	N
page	N

Must	N
it	N
be	N
a	N
regex	N
?	N
You	N
can	N
use	N
the	N
DOM	N
to	N
obtain	N
such	N
information	N
,	N
here	N
is	N
a	N
trivial	N
example	N
of	N
getting	N
the	N
contents	N
of	N
the	N
BODY	N
tag	N
,	N
you	N
could	N
apply	N
it	N
to	N
whatever	N
you	N
like	N
:	N

+1	N
Yes	N
!	N
Parsing	N
non-regular	N
strings	N
with	N
regular	N
expressions	N
is	N
WRONG	N
!	N

+1	N
.	N
I	N
love	N
regex	N
,	N
but	N
use	N
the	N
right	N
tool	N
for	N
the	N
job	N
.	N
regex	N
is	N
the	N
wrong	N
tool	N
for	N
this	N
job	N
.	N

While	N
I	N
agree	N
in	N
principle	N
,	N
he's	N
trying	N
to	N
do	N
this	N
via	N
the	N
GWT	N
which	N
uses	N
java	N
to	N
create	N
javascript	N
.	N

This	N
seems	N
to	N
do	N
what	N
you	N
want	N
:	N
That	N
being	N
said	N
,	N
you	N
would	N
probably	N
be	N
better	N
off	N
using	N
something	N
like	N
Tag	N
Soup	N
if	N
it	N
is	N
at	N
all	N
possible	N
.	N

I'm	N
marking	N
this	N
as	N
the	N
correct	N
answer	N
since	N
it	N
does	N
what	N
I	N
originally	N
wanted	N
.	N
Also	N
,	N
laz	N
provided	N
me	N
with	N
the	N
secondary	N
answer	N
(	N
below	N
)	N
that	N
I	N
needed	N
for	N
the	N
final	N
solution	N
.	N

Is	N
that	N
correct	N
?	N
I	N
would	N
think	N
the	N
last	N
peren	N
should	N
be	N
inside	N
the	N
tag	N
like	N
this	N
:	N
]*	N
src	N
=[	N
'	N
\	N
"	N
]	N
(	N
[^	N
'	N
\	N
"	N
]*	N
)	N
[	N
'	N
\	N
"	N
][^	N
>	N
]*	N
>	N
|[^	N
>	N
]*	N
>	N
(	N
[^	N
<	N
]*	N
))	N
because	N
I	N
believe	N
script	N
tags	N
not	N
specified	N
always	N
with	N
a	N
closing	N
node	N
,	N
not	N
shorthand	N
,	N
so	N
,	N
never	N
/	N
>	N

You	N
are	N
technically	N
correct	N
,	N
which	N
is	N
the	N
best	N
kind	N
of	N
correct	N
of	N
course	N
,	N
except	N
that	N
HTML	N
in	N
the	N
wild	N
can	N
certainly	N
be	N
malformed	N
and	N
if	N
a	N
browser	N
can	N
render	N
it	N
(	N
or	N
ever	N
did	N
)	N
,	N
be	N
assured	N
someone	N
once	N
wrote	N
it	N
that	N
way	N
!	N
Since	N
Matt	N
seems	N
to	N
have	N
controlled	N
the	N
HTML	N
being	N
parsed	N
though	N
,	N
he	N
might	N
not	N
have	N
needed	N
to	N
handle	N
that	N
scenario	N
.	N

Thanks	N
for	N
all	N
the	N
great	N
suggestions	N
everyone	N
.	N
I	N
quickly	N
discovered	N
it's	N
not	N
possible	N
to	N
use	N
Java's	N
Regex	N
API	N
in	N
GWT	N
and	N
was	N
able	N
to	N
do	N
what	N
I	N
wanted	N
with	N
JSNI	N
.	N
Unfortunately	N
,	N
I	N
ran	N
into	N
additional	N
issues	N
as	N
documented	N
in	N
the	N
following	N
thread	N
:	N
http://groups.google.com/group/Google-Web-Toolkit/browse_thread/thread/ac2589369ddec8a3	N

I	N
guessing	N
that	N
the	N
call	N
to	N
eval	N
(	N
scripts[i]	N
.	N
getAttribute	N
(	N
"	N
src	N
"))	N
doesn't	N
not	N
load	N
the	N
URL	N
that	N
src=	N
""	N
points	N
to	N
.	N
It	N
is	N
simply	N
trying	N
to	N
execute	N
the	N
actual	N
URL	N
string	N
as	N
JavaScript	N
.	N
You	N
need	N
to	N
figure	N
out	N
how	N
to	N
load	N
the	N
contents	N
of	N
that	N
URL	N
and	N
eval	N
it	N
.	N

Ugh	N
,	N
I	N
=	N
I'm	N
and	N
doesn't	N
not	N
=	N
does	N
not	N

Thanks	N
for	N
the	N
suggestion	N
.	N
It	N
allowed	N
me	N
to	N
solve	N
my	N
problem	N
.	N
Here's	N
the	N
solution	N
I	N
came	N
up	N
with	N
:	N
http://groups.google.com/group/Google-Web-Toolkit/msg/0d076f647a4472bc	N

