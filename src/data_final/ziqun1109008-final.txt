1109008	Regexp to match Javascript string literals with a specific keyword using Java	^ P V ^ N V P D A ^ V ^
1109008	After much revision ( see edit history , viewers at home :) , I believe this is my final answer :	P A N , V V N , N P N E , O V D V D A N ,
1109008	It does when I test it ... test case 3 matches properly as 2 string literals . Here is where the original regex came from http://blog.stevenlevithan.com/archives/match-quoted-string	O V R O V O , N N E V R P $ N V , R V R D A N V P U
1109008	Oops , I see . Yeah , it's relying on the non-greedy behavior for that , which you can't use the same way because you're anchoring to a keyword . Editing ...	! , O V , ! , L V P D A N P O , D O V V D A N P L V P D ^ , ! ~
1109008	That should work but the problem in my case would be false-positives . The probability of a string literal having the special keyword is about 1% . And I have to process a lot of files with hundreds of lines every time . If no one can come up with a way to pre-screen the literals for the special keyword before processing them , I'll go with your solution .	O V N & D N P D N V V V , D N P D N N V D A ^ V P $ , & O V P N D N P N P N P V D N , P D N V V T P D N P V D ^ P D A ^ P V O , L V P D N ,
1109008	Maybe further developments will help ...	R A N V N ,
1109008	It seems to match a lot more than needed . In my test case chunk above , it matched : " test " ; var v2 = " testkeyword " ; var v3 = " test " ; var v4 = " testkeyword " ;	O V P V D N R P V , P D N N N P , O V , , N , G G $ G , ^ , E E E E , N , G ^ $ G , ^ , ,
1109008	Tim's modification of your Regexp above works correctly .	Z N P D ^ P V R ,
1109008	Cool . Glad to have helped , anyhow .	A , A P V V , R ,
1109008	How about this modification :	R P D N ,
1109008	Perfect ! Works as needed !	A , V P V ,
1109008	You need to write two patterns for either single or double quoted strings , as there is no way to make the regex remember which opened the string . Then you can or them together with | .	O V P V $ N P D A & R V N , P X V D N P V D N V O V D N , R O V & O R P G ,
1109008	Consider using code from Rhino -- JS in Java -- to get the real String literals . Or , if you want to use regex , consider one find for the whole literal , then a nested test if the literal contains ' keyword ' . I think Tim's construction works , but I wouldn't bet on it in all situations , and the regex would have to get insanely unwieldy if it had to deal with literals that don't want to be found ( as if trying to sneak by your testing ) . For example : Separate from any solution , my secret weapon for interactively working out regexes is a tool I made called Regex Powertoy , which unlike many such utilities runs in any browser with Java applet support .	V V N P ^ ^ ^ P ^ , P V D A N ^ , ^ , P O V P V N , V O V P D A N , R D V N P D A N , ^ , , O V Z N V , & O V V P O P D N , & D N V V P V R A P O V P N P V O V V P V V , R P V P V P D N , , P N , V P D N , D A N P ^ V T O V D N O V V ^ ^ , O P A A N V P D N P ^ N N ,
1109008	The test case you mentioned does not apply to my situation . I'm guaranteed that ' keyword ' will appear just like that , in ASCII . Doing two tests ( first test for string literal , then test for presence of keyword ) will produce a lot of false-positives in my case because probability of a literal having a keyword is about 1% .	D N N O V V R V P D N , L A O , ^ , V V R P O , P ^ , V $ N , A N P V A , R N P N P ^ , V V D N P V P D N P N P D N V D ^ V P $ ,
1109008	Interesting observation . Do you happen to have a test case that will break Tim's solution ? It seems to be holding up to all of my test cases .	A N , V O V P V D N N O V V Z N , O V P V V T P X P D N N ,
