Good	N
choice	N
for	N
a	N
lightweight	N
checksum	N
algorithm	N
?	N

I	N
find	N
myself	N
needing	N
to	N
generate	N
a	N
checksum	N
for	N
a	N
string	N
of	N
data	N
,	N
for	N
consistency	N
purposes	N
.	N
The	N
broad	N
idea	N
is	N
that	N
the	N
client	N
can	N
regenerate	N
the	N
checksum	N
based	N
on	N
the	N
payload	N
it	N
recieves	N
and	N
thus	N
detect	N
any	N
corruption	N
that	N
took	N
place	N
in	N
transit	N
.	N
I	N
am	N
vaguely	N
aware	N
that	N
there	N
are	N
all	N
kinds	N
of	N
mathematical	N
principles	N
behind	N
this	N
kind	N
of	N
thing	N
,	N
and	N
that	N
it's	N
very	N
easy	N
for	N
subtle	N
errors	N
to	N
make	N
the	N
whole	N
algorithm	N
ineffective	N
if	N
you	N
try	N
to	N
roll	N
it	N
yourself	N
.	N
So	N
I'm	N
looking	N
for	N
advice	N
on	N
a	N
hashing	N
/	N
checksum	N
algorithm	N
with	N
the	N
following	N
criteria	N
:	N
It	N
will	N
be	N
generated	N
by	N
Javascript	N
,	N
so	N
needs	N
to	N
be	N
relatively	N
light	N
computationally	N
.	N
The	N
validation	N
will	N
be	N
done	N
by	N
Java	N
(	N
though	N
I	N
cannot	N
see	N
this	N
actually	N
being	N
an	N
issue	N
)	N
.	N
It	N
will	N
take	N
textual	N
input	N
(	N
URL-encoded	N
Unicode	N
,	N
which	N
I	N
believe	N
is	N
ASCII	N
)	N
of	N
a	N
moderate	N
length	N
;	N
typically	N
around	N
200-300	N
characters	N
and	N
in	N
all	N
cases	N
below	N
2000	N
.	N
The	N
output	N
should	N
be	N
ASCII	N
text	N
as	N
well	N
,	N
and	N
the	N
shorter	N
it	N
can	N
be	N
the	N
better	N
.	N
I'm	N
primarily	N
interested	N
in	N
something	N
lightweight	N
rather	N
than	N
getting	N
the	N
absolute	N
smallest	N
potential	N
for	N
collisions	N
possible	N
.	N
Would	N
I	N
be	N
naive	N
to	N
imagine	N
that	N
an	N
eight-character	N
hash	N
would	N
be	N
suitable	N
for	N
this	N
?	N
I	N
should	N
also	N
clarify	N
that	N
it's	N
not	N
the	N
end	N
of	N
the	N
world	N
if	N
corruption	N
isn't	N
picked	N
up	N
at	N
the	N
validation	N
stage	N
(	N
and	N
I	N
do	N
realise	N
that	N
this	N
will	N
not	N
be	N
100%	N
reliable	N
)	N
,	N
though	N
the	N
rest	N
of	N
my	N
code	N
is	N
markedly	N
less	N
efficient	N
for	N
every	N
corrupt	N
entry	N
that	N
slips	N
through	N
.	N
Edit	N
-	N
thanks	N
to	N
all	N
that	N
contributed	N
.	N
I	N
went	N
with	N
the	N
Adler32	N
option	N
and	N
given	N
that	N
it	N
was	N
natively	N
supported	N
in	N
Java	N
,	N
extremely	N
easy	N
to	N
implement	N
in	N
Javascript	N
,	N
fast	N
to	N
calculate	N
at	N
both	N
ends	N
and	N
have	N
an	N
8-b	N
yte	N
output	N
it	N
was	N
exactly	N
right	N
for	N
my	N
requirements	N
.	N
(	N
Note	N
that	N
I	N
realise	N
that	N
the	N
network	N
transport	N
is	N
unlikely	N
to	N
be	N
responsible	N
for	N
any	N
corruption	N
errors	N
and	N
won't	N
be	N
folding	N
my	N
arms	N
on	N
this	N
issue	N
just	N
yet	N
;	N
however	N
adding	N
the	N
checksum	N
validation	N
removes	N
one	N
point	N
of	N
failure	N
and	N
means	N
we	N
can	N
focus	N
on	N
other	N
areas	N
should	N
this	N
reoccur	N
.	N
)	N

So	N
the	N
whole	N
TCP	N
/	N
IP	N
checksum	N
thing	N
isn't	N
working	N
...	N
I'm	N
thinking	N
that	N
anything	N
corrupted	N
in	N
transit	N
is	N
going	N
to	N
get	N
rejected	N
at	N
a	N
much	N
lower	N
layer	N
than	N
the	N
application	N
level	N
.	N

Yeah	N
,	N
this	N
sounds	N
like	N
something	N
usually	N
left	N
to	N
the	N
transport	N
layer	N
.	N
Can	N
you	N
explain	N
your	N
scenario	N
a	N
little	N
more	N
?	N
Where	N
is	N
your	N
data	N
being	N
sent	N
and	N
what	N
specific	N
causes	N
of	N
data	N
corruption	N
are	N
you	N
trying	N
to	N
guard	N
against	N
?	N

@dtsazza	N
-	N
you	N
mentioned	N
in	N
a	N
comment	N
below	N
that	N
this	N
is	N
for	N
security	N
(	N
malicious	N
users	N
)	N
.	N
Can	N
you	N
elaborate	N
?	N
Especially	N
since	N
this	N
will	N
probably	N
run	N
in	N
a	N
browser	N
.	N

Use	N
SHA-1	N
JS	N
implementation	N
.	N
It's	N
not	N
as	N
slow	N
as	N
you	N
think	N
(	N
Firefox	N
3.0	N
on	N
Core	N
2	N
Duo	N
2.4	N
Ghz	N
hashes	N
over	N
100KB	N
per	N
second	N
)	N
.	N

[	N
UPDATE	N
30	N
/	N
5	N
/	N
2013	N
:	N
The	N
link	N
to	N
the	N
old	N
JS	N
CRC32	N
implementation	N
died	N
,	N
so	N
I've	N
now	N
linked	N
to	N
a	N
different	N
one	N
.	N
]	N
Google	N
CRC32	N
:	N
fast	N
,	N
and	N
much	N
lighter	N
weight	N
than	N
MD5	N
et	N
al	N
.	N
There	N
is	N
a	N
Javascript	N
implementation	N
here	N
.	N

Link	N
now	N
broken	N
unfortunately	N
.	N

@JamesWestgate	N
:	N
Thanks	N
James	N
,	N
I've	N
found	N
a	N
new	N
one	N
and	N
linked	N
to	N
that	N
.	N
Incidentally	N
the	N
first	N
JS	N
version	N
I	N
found	N
(	N
at	N
http://noteslog.com/post/crc32-for-javascript/)	N
actually	N
reparses	N
part	N
of	N
the	N
string	N
containing	N
the	N
table	N
for	N
each	N
character	N
processed	N
,	N
which	N
will	N
make	N
it	N
*	N
much	N
*	N
slower	N
than	N
necessary	N
.	N

Awesome	N
!	N
Thanks	N
:)	N
Looking	N
for	N
something	N
to	N
checksum	N
javascript	N
functions	N
for	N
a	N
browser	N
based	N
animation	N
code	N
generation	N
tool	N
.	N

CRC32	N
is	N
not	N
too	N
hard	N
to	N
implement	N
in	N
any	N
language	N
,	N
it	N
is	N
good	N
enough	N
to	N
detect	N
simple	N
data	N
corruption	N
and	N
when	N
implemted	N
in	N
a	N
good	N
fashion	N
,	N
it	N
is	N
very	N
fast	N
.	N
However	N
you	N
can	N
also	N
try	N
Adler32	N
,	N
which	N
is	N
almost	N
equally	N
good	N
as	N
CRC32	N
,	N
but	N
it's	N
even	N
easier	N
to	N
implement	N
(	N
and	N
about	N
equally	N
fast	N
)	N
.	N
Adler32	N
in	N
the	N
Wikipedia	N
CRC32	N
JavaScript	N
implementation	N
sample	N
Either	N
of	N
these	N
two	N
(	N
or	N
maybe	N
even	N
both	N
)	N
are	N
available	N
in	N
Java	N
right	N
out	N
of	N
the	N
box	N
.	N

CRC32	N
,	N
definitely	N
was	N
designed	N
to	N
be	N
exactly	N
what	N
you	N
describe	N
.	N

A	N
word	N
of	N
caution	N
:	N
the	N
JavaScript	N
in	N
the	N
link	N
implements	N
the	N
algorithm	N
with	N
a	N
table[256	N
]	N
of	N
literal	N
values	N
.	N
If	N
you	N
should	N
modify	N
even	N
a	N
single	N
digit	N
of	N
that	N
table	N
,	N
you	N
will	N
have	N
a	N
nasty	N
bug	N
that	N
is	N
very	N
,	N
very	N
,	N
hard	N
to	N
find	N
!	N
I	N
prefer	N
implementations	N
that	N
generate	N
the	N
table	N
on	N
the	N
1st	N
call	N
.	N

I'll	N
second	N
@D	N
.i.S's	N
comment	N
.	N
Testability	N
is	N
a	N
minus	N
.	N

Javascript	N
implementation	N
of	N
MD4	N
,	N
MD5	N
and	N
SHA1	N
.	N
BSD	N
license	N
.	N

Are	N
aware	N
that	N
both	N
TCP	N
and	N
UDP	N
(	N
and	N
IP	N
,	N
and	N
Ethernet	N
,	N
and	N
...	N
)	N
already	N
provide	N
checksum	N
protection	N
to	N
data	N
in	N
transit	N
?	N
Unless	N
you're	N
doing	N
something	N
really	N
weird	N
,	N
if	N
you're	N
seeing	N
corruption	N
,	N
something	N
is	N
very	N
wrong	N
.	N
I	N
suggest	N
starting	N
with	N
a	N
memory	N
tester	N
.	N
Also	N
,	N
you	N
receive	N
strong	N
data	N
integrity	N
protection	N
if	N
you	N
use	N
SSL	N
/	N
TLS	N
.	N

Yes	N
,	N
I	N
am	N
was	N
aware	N
of	N
that	N
,	N
though	N
you	N
were	N
right	N
to	N
point	N
it	N
out	N
.	N
Unfortunately	N
it's	N
in	N
input	N
coming	N
from	N
the	N
world	N
at	N
large	N
,	N
so	N
we	N
need	N
to	N
be	N
able	N
to	N
cope	N
with	N
this	N
anyway	N
(	N
malicious	N
/	N
mischevious	N
users	N
could	N
mangle	N
this	N
for	N
example	N
)	N
.	N

It	N
might	N
be	N
worth	N
pointing	N
out	N
that	N
for	N
any	N
change-detection	N
algorithm	N
,	N
there	N
is	N
always	N
a	N
chance	N
that	N
it	N
won't	N
detect	N
an	N
error	N
.	N
They	N
all	N
can	N
have	N
collisions	N
or	N
false-negatives	N
,	N
though	N
usually	N
the	N
more	N
expensive	N
algorithms	N
reduce	N
this	N
chance	N
to	N
near-astronomically	N
small	N
probabilities	N
.	N

@dtsazza	N
:	N
I	N
wonder	N
about	N
the	N
malicious	N
/	N
mischievous	N
users	N
who	N
can	N
mangle	N
packets	N
going	N
across	N
the	N
network	N
,	N
but	N
can't	N
defeat	N
Javascript	N
.	N
Or	N
Adler32	N
.	N

Other	N
people	N
have	N
mentioned	N
CRC32	N
already	N
,	N
but	N
here's	N
a	N
link	N
to	N
the	N
W3C	N
implementation	N
of	N
CRC-32	N
for	N
PNG	N
,	N
as	N
one	N
of	N
the	N
few	N
well-known	N
,	N
reputable	N
sites	N
with	N
a	N
reference	N
CRC	N
implementation	N
.	N
(	N
A	N
few	N
years	N
back	N
I	N
tried	N
to	N
find	N
a	N
well-known	N
site	N
with	N
a	N
CRC	N
algorithm	N
or	N
at	N
least	N
one	N
that	N
cited	N
the	N
source	N
for	N
its	N
algorithm	N
,	N
was	N
almost	N
tearing	N
my	N
hair	N
out	N
until	N
I	N
found	N
the	N
PNG	N
page	N
.	N
)	N

Here's	N
a	N
relatively	N
simple	N
one	N
I've	N
'	N
invented	N
'	N
-	N
there's	N
no	N
mathematical	N
research	N
behind	N
it	N
but	N
it's	N
extremely	N
fast	N
and	N
works	N
in	N
practice	N
.	N
I've	N
also	N
included	N
the	N
Java	N
equivalent	N
that	N
tests	N
the	N
algorithm	N
and	N
shows	N
that	N
there's	N
less	N
than	N
1	N
in	N
10,000,000	N
chance	N
of	N
failure	N
(	N
it	N
takes	N
a	N
minute	N
or	N
two	N
to	N
run	N
)	N
.	N
JavaScript	N
Java	N

Why	N
?	N
Would	N
you	N
like	N
to	N
share	N
an	N
example	N
?	N

This	N
is	N
a	N
rather	N
old	N
thread	N
but	N
I	N
suspect	N
it	N
is	N
still	N
viewed	N
quite	N
often	N
so	N
-	N
if	N
all	N
you	N
need	N
is	N
a	N
short	N
but	N
reliable	N
piece	N
of	N
code	N
to	N
generate	N
a	N
checksum	N
the	N
Adler32	N
bit	N
algorithm	N
has	N
to	N
be	N
your	N
choice	N
.	N
Here	N
is	N
the	N
JavaScript	N
code	N
The	N
corresponding	N
fiddle	N
demonsrating	N
the	N
algorithm	N
in	N
action	N
is	N
here	N
.	N

In	N
my	N
search	N
for	N
a	N
JavaScript	N
implementation	N
of	N
a	N
good	N
checksum	N
algorithm	N
I	N
came	N
across	N
this	N
question	N
.	N
Andrzej	N
Doyle	N
rightfully	N
chose	N
Adler32	N
as	N
the	N
checksum	N
,	N
as	N
it	N
is	N
indeed	N
easy	N
to	N
implement	N
and	N
has	N
some	N
excellent	N
properties	N
.	N
DroidOS	N
then	N
provided	N
an	N
actual	N
implementation	N
in	N
JavaScript	N
,	N
which	N
demonstrated	N
the	N
simplicity	N
.	N
However	N
,	N
the	N
algorithm	N
can	N
be	N
further	N
improved	N
upon	N
as	N
detailed	N
in	N
the	N
Wikipedia	N
page	N
and	N
as	N
implemented	N
below	N
.	N
The	N
trick	N
is	N
that	N
you	N
need	N
not	N
determine	N
the	N
modulo	N
in	N
each	N
step	N
.	N
Rather	N
,	N
you	N
can	N
defer	N
this	N
to	N
the	N
end	N
.	N
This	N
considerably	N
increases	N
the	N
speed	N
of	N
the	N
implementation	N
,	N
up	N
to	N
6x	N
faster	N
on	N
Chrome	N
and	N
Safari	N
.	N
In	N
addition	N
,	N
this	N
optimalisation	N
does	N
not	N
affect	N
the	N
readability	N
of	N
the	N
code	N
making	N
it	N
a	N
win-win	N
.	N
As	N
such	N
,	N
it	N
definitely	N
fits	N
in	N
well	N
with	N
the	N
original	N
question	N
as	N
to	N
having	N
an	N
algorithm	N
/	N
implementation	N
that	N
is	N
computationally	N
light	N
.	N
edit	N
:	N
imaya	N
created	N
a	N
jsperf	N
comparison	N
a	N
while	N
back	N
showing	N
the	N
difference	N
in	N
speed	N
when	N
running	N
the	N
simple	N
version	N
,	N
as	N
detailed	N
by	N
DroidOS	N
,	N
compared	N
to	N
an	N
optimised	N
version	N
that	N
defers	N
the	N
modulo	N
operation	N
.	N
I	N
have	N
added	N
the	N
above	N
implementation	N
under	N
the	N
name	N
full-length	N
to	N
the	N
jsperf	N
page	N
showing	N
that	N
the	N
above	N
implementation	N
is	N
about	N
25%	N
faster	N
than	N
the	N
one	N
from	N
imaya	N
and	N
about	N
570%	N
faster	N
than	N
the	N
simple	N
implementation	N
(	N
tests	N
run	N
on	N
Chrome	N
30	N
):	N
http://jsperf.com/adler-32-simple-vs-optimized/6	N
edit2	N
:	N
please	N
don't	N
forget	N
that	N
,	N
when	N
working	N
on	N
large	N
files	N
,	N
you	N
will	N
eventually	N
hit	N
the	N
limit	N
of	N
your	N
JavaScript	N
implementation	N
in	N
terms	N
of	N
the	N
a	N
and	N
b	N
variables	N
.	N
As	N
such	N
,	N
when	N
working	N
with	N
a	N
large	N
data	N
source	N
,	N
you	N
should	N
perform	N
intermediate	N
modulo	N
operations	N
as	N
to	N
ensure	N
that	N
you	N
do	N
not	N
exceed	N
the	N
maximum	N
value	N
of	N
the	N
integer	N
that	N
you	N
can	N
reliably	N
store	N
.	N

