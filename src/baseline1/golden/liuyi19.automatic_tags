md5 hash for password string in GWT / GWT-Ext ?	^ N P N N P ^ , ^ ,
I am currently trying to modify an existing GWT-Ext application , that is using plain text passwords in its MySql database . My plan was to use md5 hashes , as the existing passwords can be easily altered with the MySql function and I was expecting to find an easy solution for the GWT-Ext side as well . But as I found out , java.security is not supported by GWT and there doesn't seem to be any other implementation that can be used to change the password string to a md5 hash on client side . Only " solution " I found so far , is to re implement a md5 method via JSNI as described here : http://groups.google.com/group/Google-Web-Toolkit/browse_thread/thread/ad09475a9944c9f8 There is an existing user extension for Ext-JS , but I couldn't find anything for GWT-Ext : http://extjs.com/forum/showthread.php?p=133516 Does anybody know a more elegant / simple way to solve this problem ? Maybe I should use something else instead of md5 to make sure the passwords are encrypted ? Cheers Frank	O V R V P V D A ^ N , O V V A N N P D ^ N , D N V P V ^ N , P D A N V V R A P D ^ N & O V V P V D A N P D ^ N P R , & P O V T , ^ V R V P ^ & R V V P V R A N P V V V P V D N N P D ^ N P N N , R , N , O V R R , V P G V D ^ N P ^ P V R , U X V D A N N P ^ , & O V V N P ^ , U V O V D R A , A N P V D N , R O V V N R R P ^ P V A D N V V , N ^
Personally , I would say you're doing it wrong . I wouldn't hash a password on the client side ( which is what GWT is ) . If you hash your password , you will undoubtedly want to salt it , otherwise you will be susceptible to rainbow attacks . If you hash + salt it on the client side , your salt will be accessible to your users . If I were you , I would hash + salt your password on the server side . This will allow you to use your standard Java code to perform your MD5 hash . My 2 cents . -JP	R , O V V L V O R , O V V D N P D N N , O V O ^ V , , P O V D N , O V R V P V O , R O V V A P N N , P O V G N O P D N N , D N V V A P D N , P O V O , O V V G N D N P D N N , D V V O P V D A ^ N P V D ^ N , D $ N , G
Its not a bad scheme if he does something like cram-md5 on the client side , where the client computes a hmac ( md5 hash plus a nonce salt ) and sends it to the server . The down side is that the server needs clear text password to check the hmac .	L R D A N P O V N P ^ P D N N , R D N V D N , ^ N V D N N , & V O P D N , D T N V P D N V A N N P V D N ,
good point about the rainbow attacks , didn't knew about this before . I also solved it by doing the encryption on the server side , but the idea was , that I wanted to encrypt the password , before sending it to the server , as we currently only use http and no https .	A N P D N N , V V P D R , O R V O P V D N P D N N , & D N V , P O V P V D N , P V O P D N , P O R R V ^ & D ^ ,
GWT is client-side and server side . Other than that , the post is good advice . Don't hash it on the client side . Have a look at http://www.owasp.org/index.php/Hashing_Java .	^ V A & N N , R P O , D N V A N , V V O P D N N , V D N P U ,
Another idea that may fit your need is something called zero knowledge auth . ( Ie . the server never needs to know the user's plain text password . ) Basically , when setting the initial password , the client hashes the user's password N times ( where N is a largish number like 1000 ) , and then sends that final hash to the server along with N . The server stores the hash and N . Later , when the user wants to authenticate , the server tells the client N-1 , and the client hashes the password the user types N-1 times and sends that to the server . The server does 1 more hash on the received hash , and ( hopefully ) gets the stored hash . The server then stores the N-1 hash and N-1 number . Each time the user authenticates , the server decrements the stored N and saves the previous hash . When N gets down to 0 , the user must choose and set a new password . The server must ensure that it never asks for the same iteration , otherwise it is vulnerable to a replay . You can't really enforce that condition from the client side because the client ( especially a browser ) can't reliably keep track of the last N .	D N P V V D N V N V $ N N , , G , D N R V P V D Z A N N , , R , O V D A N , D N V D Z N G N , R G V D A N P $ , , & R V D A N P D N P P G , D N V D N & G , R , R D N V P V , D N V D N G , & D N V D N D N V G N & V O P D N , D N V $ A N P D A N , & , R , V D A N , D N R V D G N & G N , D N D N V , D N V D V G & V D A N , R & V T P $ , D N V V & V D A N , D N V V P O R V P D A N , R O V A P D N , O V R V D N P D N N P D N , R D N , V R V N P D A G ,
Very interesting idea , and never thought of that before . Doesn't really fit in the current solution , but I will keep it in mind for future reference , thanks :-)	R A N , & R V P O R , V R V P D A N , & O V V O P N P A N , N E
Interesting idea so I spent some time thinking about it , but it is vulnerable to a man-in-the-middle attack . On an authentication request , the server sends some number M . The attacker sends ( M-1 ) to the client , and receives hash ( M-1 ) back . The attacker tries to authenticate again , receives challenge ( M-1 ) from the server and responds with hash ( M-1 ) . The attacker is now authenticated .	A N P O V D N V P O , & O V A P D A N , P D N N , D N V D N G , D N V , ^ , P D N , & V N , ^ , R , D N V P V R , V N , ^ , P D N & V P N , ^ , , D N V R V ,
yes , that does sound like an issue . My first thought would be to require the server to not reuse M after issuing it during a challenge to the client . However , the larger issue remains that Mallory could tell the client M-100 , collect the hash ( M-100 ) from the client , and then login up to 100 times with the intercepted hash . I'll have to go see if the project that I first encountered this in found the same issues and dealt with it or abandoned zero knowledge auth .	! , O V V P D N , D A N V V P V D N P R V G P V O P D N P D N , R , D A N V D ^ V V D N ^ , V D N , ^ , P D N , & R V T P $ N P D A N , L V P V V P D N P O R V D P V D A N & V P O & A $ N N ,
I think you're always going to be vulnerable to a man in the middle attack . Keyloggers too . Also drunken confessions of passwords . We can only raise the bar so far with reasonable coding efforts .	O V L R V P V A P D N P D A N , ^ R , R A N P N , O V R V D N R R P A N N ,
You can use gwt-crypto to generate SHA-1 hashes on the client side using :	O V V ^ P V ^ N P D N N V ,
You should never use an md5 or other hash functions for password encryption . See http://codahale.com/how-to-safely-store-a-password /	O V R V D ^ & A N N P N N , V U ,
